using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;
using Random = UnityEngine.Random;

namespace MSVehicle {
  [RequireComponent(typeof(Rigidbody))]
  [DisallowMultipleComponent]
  public class MSVehicleController : MonoBehaviour {
    public Transform SkidMarksContainer;

    [Tooltip("If this variable is checked, the vehicle will automatically manage the gearshift.")]
    public bool automaticGears = true;
    [Tooltip("The simulation rate of the vehicle wheels. This represents how many extra simulations will be made for the wheels beyond the simulation of physics. The more 'substeps', the greater the accuracy.")]
    public VehicleSubstepsClass substeps;
    [Tooltip("In this variable, empty objects must be associated with positions close to the vehicle doors.")]
    public GameObject[] doorPosition;

    [Tooltip("In this class you can configure the vehicle torque, number of gears and their respective torques.")]
    public TorqueAdjustmentClass _vehicleTorque;

    [Tooltip("In this class you can configure the vehicle suspension.")]
    public SuspensionAdjustmentClass _suspension;

    [Tooltip("Here it is possible to define how the physics of the vehicle will happen. In general, the behavior of the vehicle is defined here.")]
    public VehiclePhysicsStabilizersClass _vehiclePhysicStabilizers;

    [Tooltip("In this class you can set the vehicle's brakes, their strength, their initial state, and how they will work.")]
    public VehicleBrakesClass _brakes;

    [Tooltip("Here you can set the initial state of some vehicle variables, such as vehicle mass, brake and engine states, among other things.")]
    public VehicleAdjustmentClass _vehicleSettings;

    [Tooltip("In this class you can adjust all the settings related to the steering wheel of the vehicle and how much the wheels will turn.")]
    public VolantSettingsClass _steeringWheel;

    [Tooltip("In this class, you can adjust all preferences relative to the fuel consumption of the vehicle.")]
    public FuelAdjustmentClass _fuel;

    [Tooltip("In this class, you can adjust all wheels of the vehicle separately, each with its own settings.")]
    public VehicleWheelsClass _wheels;

    [Tooltip("In this class, you can adjust all vehicle lights, and the preferences of each.")]
    public VehicleLightsClass _lights;

    [Tooltip("In this class, you can adjust all vehicle sounds, and the preferences of each.")]
    public VehicleSoundsClass _sounds;

    [Tooltip("In this class, you can adjust vehicle particles, and the preferences of each.")]
    public VehicleParticlesClass _particles;

    [Tooltip("In this class, you can adjust some indicators, such as the 'speedometer' and the RPM gauge.")]
    public SpeedometerAndOthersClass _speedometer;

    [Tooltip("Here you can configure various additional features of the vehicle, such as nitro, among others.")]
    public VehicleAdditionalSettingsClass _additionalFeatures;

    public enum GroundDetectionMode { Tag, PhysicMaterial, TerrainTextureIndices, All };
    [Space(18)]
    [Tooltip("Here you can decide how the wheels of the vehicle will detect the ground, whether it is through Tag, PhysicMaterial, Index of texture or all at the same time. For performance reasons, the option 'ALL' is not advised because it is the heaviest.")]
    public GroundDetectionMode _groundDetection = GroundDetectionMode.All;

    [Tooltip("Here you can set the terrain on which the vehicle will walk. This variable is optional, because if you leave it empty, the code will fetch the active terrain automatically.")]
    public Terrain activeTerrain_optional;

    [Tooltip("In this class it is possible to define and configure all sounds that the vehicle will emit relative to the ground.")]
    public VehicleGroundSoundsClass _groundSounds;

    [Tooltip("In this class, you can adjust all the terrains on which the vehicle will walk, and set the friction of each of them.")]
    public GroundFrictionClass _groundFriction;

    [Tooltip("In this class, you can adjust the particles that the wheels of the vehicle will emit on each type of terrain.")]
    public DustParticleClass[] _groundParticles;

    [Tooltip("In this class, you can adjust all preferences in relation to vehicle skid marks, such as color, width, among other options.")]
    public VehicleSkidMarksClass _skidMarks;

    [Space(5)]
    [Header("Resources")]
    [Tooltip("In this variable, the 'SkidMarks' shader must be associated. Otherwise, the vehicle will not generate skid marks.")]
    public Shader skidMarksShader;
    [Tooltip("In this variable must be associated a dust particle generated by the wheels. If no particle is associated with this variable, the vehicle will not emit particles in the ground.")]
    public ParticleSystem wheelDustParticle;
    [HideInInspector]
    public GameObject _mainSceneControl;


    [HideInInspector]
    public float verticalInput = 0;
    [HideInInspector]
    public float horizontalInput = 0;
    [HideInInspector]

    bool _error = false;
    bool changinGearsAuto;
    bool brakingAuto;
    bool colliding;
    bool windLoop;
    bool boolTimeAirBrake;

    bool loopBlinkersOn;

    bool enableLightsOnStart;
    bool enableSkidMarksOnStart;
    bool enableParticlesOnStart;

    float mediumRPM;
    float volantDir_horizontalInput;
    float angleSteeringClamp;
    float finalAngleDegress;
    float angleVolantIntern;
    float volantStartRotation;
    float previousRotation;
    float volantDistortion = 0;
    float lastKnownTorque = 0;
    float speedLerpSound = 5;
    float vehicleScale;

    [HideInInspector]
    public float pitchAUDforRPM = 1;
    [HideInInspector]
    public float previousDelayStartEngine = 1;

    float rpmTorqueFactor;

    public float fixedDeltaTime;

    float rpmFactorSpeedometerModel1 = 0;
    float speedFactorSpeedometerModel1 = 0;
    float rpmFactorSpeedometerModel2 = 0;
    float speedFactorSpeedometerModel2 = 0;
    Vector3 speedPointerStartRotation;
    Vector3 rpmPointerStartRotation;
    Vector3 fuelPointerStartRotation;

    float intensityFlashingL;
    float brakeLightIntensityParameter;
    float intensitySirenL;

    float lastRightFrontPositionY;
    float lastLeftFrontPositionY;
    float lastRightRearPositionY;
    float lastLeftRearPositionY;
    float sensImpactFR;
    float sensImpactFL;
    float sensImpactRR;
    float sensImpactRL;
    float currentEngineBrakeLerpValue;

    float[] lastPositionYExtraWheels;
    float[] sensImpactExtraWheels;
    float[] headlightsRange;
    int[] wheelEmitterSoundX;
    int[] wheelBlockSoundX;
    int[] wheelEmitterSoundXSkid;
    int[] wheelBlockSoundXSkid;
    bool forwardTempSKid;
    bool forwardHandBrakeSKid;

    public Rigidbody ms_Rigidbody;

    [HideInInspector]
    public AudioSource engineSoundAUD;
    [HideInInspector]
    public AudioSource engineStartSoundAUD;
    AudioSource flashingSoundAUD;
    AudioSource hornSoundAUD;
    AudioSource beatsSoundAUD;
    AudioSource beatsOnWheelSoundAUD;
    AudioSource skiddingSoundAUD;
    AudioSource windSoundAUD;
    AudioSource airBrakeSoundAUD;
    AudioSource sirenSoundAUD;
    AudioSource handBrakeSoundAUD;
    AudioSource nitroSoundAUD;
    AudioSource[] groundSoundsAUD;
    AudioSource[] groundSoundsAUDSkid;

    bool handBrakeSoundWasPlayed;
    bool nitroSoundWasPlayed;

    WheelCollider[] wheelColliderList;
    Vector2 tireSL;
    Vector2 tireFO;
    float averageWheelRadius;

    WheelHit tempWheelHit;

    float inclinationFactorForcesDown;
    float downForceFixedUpdateRef;

    bool isBraking;
    float absLerpFactor;

    float reverseForceTimer;

    bool wheelFDIsGrounded;
    bool wheelFEIsGrounded;
    bool wheelTDIsGrounded;
    bool wheelTEIsGrounded;
    int groundedWheels;

    private readonly Dictionary<Mesh, int> currentIndexes = new Dictionary<Mesh, int>();
    Vector3[] lastPoint;
    int CacheSize = 2400;
    List<Vector3> vertices;
    List<Vector3> normals;
    List<Color> colors;
    List<Vector2> uv;
    List<int> tris;

    //terrain
    TerrainData terrainData;
    float[] terrainCompositionArray;
    float[,,] alphaMaps;
    float[] terrainCompositionMix;

    [HideInInspector]
    public float KMh;
    public int currentGear;
    [HideInInspector]
    public bool handBrakeTrue;
    [HideInInspector]
    public float vehicleLife;
    [HideInInspector]
    public float currentFuelLiters;
    [HideInInspector]
    public bool hornIsOn;
    [HideInInspector]
    public bool youCanCall;
    [HideInInspector]
    public bool theEngineIsRunning;
    [HideInInspector]
    public bool enableEngineSound;
    [HideInInspector]
    public bool changinGears;
    [HideInInspector]
    public bool lowLightOn;
    [HideInInspector]
    public bool highLightOn;
    [HideInInspector]
    public float brakeLightsIntensity;
    [HideInInspector]
    public bool headlightsOn;
    [HideInInspector]
    public bool disableBlinkers1;
    [HideInInspector]
    public bool disableBlinkers2;
    [HideInInspector]
    public bool alertOn;
    [HideInInspector]
    public bool rightBlinkersOn;
    [HideInInspector]
    public bool leftBlinkersOn;
    [HideInInspector]
    public bool extraLightsOn;

    //light hide variables
    [HideInInspector]
    public bool msvs_useMainLights;
    [HideInInspector]
    public bool msvs_useHeadLights;
    [HideInInspector]
    public bool msvs_useExtraLights;
    [HideInInspector]
    public bool msvs_useWarningOrFlashingLights;

    public enum ControlState { isNull, isPlayer };
    [HideInInspector]
    public ControlState _vehicleState = ControlState.isNull;

#if UNITY_EDITOR
    private void OnValidate() {
      //The 'OnValidate' function is called only in the editor.
      //suspension
      if (_suspension != null) {
        for (int x = 0; x < _suspension.vehicleCustomHeights.Length; x++) {
          if (_suspension.vehicleCustomHeights[x] < 0.1f) {
            _suspension.vehicleCustomHeights[x] = 0.25f;
          }
        }
      }

      //extra wheels
      if (_wheels != null) {
        for (int x = 0; x < _wheels.extraWheels.Length; x++) {
          if (_wheels.extraWheels[x].angleFactor < 0.01f) {
            _wheels.extraWheels[x].angleFactor = 1;
          }
          if (_wheels.extraWheels[x].customBrandWidth < 0.1f) {
            _wheels.extraWheels[x].customBrandWidth = 0.3f;
          }
          if (_wheels.extraWheels[x].torqueFactor < 0.1f) {
            _wheels.extraWheels[x].torqueFactor = 1.0f;
          }

          //custom friction extra wheels
          if (_wheels.extraWheels[x].adjustCustomFriction.ForwardFriction.ExtremumSlip <= 0) {
            _wheels.extraWheels[x].adjustCustomFriction.ForwardFriction.ExtremumSlip = 1.0f;
          }
          if (_wheels.extraWheels[x].adjustCustomFriction.ForwardFriction.ExtremumValue <= 0) {
            _wheels.extraWheels[x].adjustCustomFriction.ForwardFriction.ExtremumValue = 1.5f;
          }
          if (_wheels.extraWheels[x].adjustCustomFriction.ForwardFriction.AsymptoteSlip <= 0) {
            _wheels.extraWheels[x].adjustCustomFriction.ForwardFriction.AsymptoteSlip = 1.5f;
          }
          if (_wheels.extraWheels[x].adjustCustomFriction.ForwardFriction.AsymptoteValue <= 0) {
            _wheels.extraWheels[x].adjustCustomFriction.ForwardFriction.AsymptoteValue = 1.0f;
          }
          //
          if (_wheels.extraWheels[x].adjustCustomFriction.SidewaysFriction.ExtremumSlip <= 0) {
            _wheels.extraWheels[x].adjustCustomFriction.SidewaysFriction.ExtremumSlip = 0.2f;
          }
          if (_wheels.extraWheels[x].adjustCustomFriction.SidewaysFriction.ExtremumValue <= 0) {
            _wheels.extraWheels[x].adjustCustomFriction.SidewaysFriction.ExtremumValue = 1.0f;
          }
          if (_wheels.extraWheels[x].adjustCustomFriction.SidewaysFriction.AsymptoteSlip <= 0) {
            _wheels.extraWheels[x].adjustCustomFriction.SidewaysFriction.AsymptoteSlip = 0.5f;
          }
          if (_wheels.extraWheels[x].adjustCustomFriction.SidewaysFriction.AsymptoteValue <= 0) {
            _wheels.extraWheels[x].adjustCustomFriction.SidewaysFriction.AsymptoteValue = 0.75f;
          }
        }
      }

      //particles
      if (_particles != null) {
        for (int x = 0; x < _particles.exhaustSmoke.Length; x++) {
          if (_particles.exhaustSmoke[x].criticalVelocity < 5) {
            _particles.exhaustSmoke[x].criticalVelocity = 40;
          }
        }
      }
      if (_groundParticles != null) {
        for (int x = 0; x < _groundParticles.Length; x++) {
          Color testColor = new Color(0, 0, 0, 0);
          if (_groundParticles[x].particleColor == testColor) {
            _groundParticles[x].particleColor = new Color(0.2f, 0.1f, 0.0f, 0.9f);
          }
          if (_groundParticles[x].criticalVelocity < 0.1f) {
            _groundParticles[x].criticalVelocity = 5;
          }
        }
      }

      //steering assist
      if (_wheels != null) {
        if (_steeringWheel != null) {
          if (_steeringWheel.steeringAssist > 0.1f) {
            if (_wheels.rightFrontWheel.wheelCollider && _wheels.rightRearWheel.wheelCollider && _wheels.leftFrontWheel.wheelCollider && _wheels.leftRearWheel.wheelCollider) {
              float frontWheelRadius = _wheels.rightFrontWheel.wheelCollider.radius + _wheels.leftFrontWheel.wheelCollider.radius;
              float rearWheelRadius = _wheels.rightRearWheel.wheelCollider.radius + _wheels.leftRearWheel.wheelCollider.radius;
              if (Mathf.Abs(frontWheelRadius - rearWheelRadius) > 0.18f) {
                _steeringWheel.steeringAssist = 0;
                Debug.LogWarning("The radius of the front wheels of the vehicle is very different from the radius of the rear wheels of the vehicle, and this can cause problems in the steering assist." +
                  "In these cases, the vehicle steering assist will be disabled automatically (SteeringWheel > Steering Assist = 0).");
              }
            }
          }
        }
      }

      //sounds
      if (_groundSounds != null) {
        for (int x = 0; x < _groundSounds.groundSounds.Length; x++) {
          if (_groundSounds.groundSounds[x].volumeSkid < 0.1f) {
            _groundSounds.groundSounds[x].volumeSkid = 0.7f;
          }
          if (_groundSounds.groundSounds[x].volumeSound < 0.01f) {
            _groundSounds.groundSounds[x].volumeSound = 0.2f;
          }
        }
      }

      //ground friction
      if (_groundFriction != null) {
        for (int x = 0; x < _groundFriction.grounds.Length; x++) {
          if (_groundFriction.grounds[x].forwardFriction < 0.1f) {
            _groundFriction.grounds[x].forwardFriction = 1.5f;
          }
          if (_groundFriction.grounds[x].sidewaysFriction < 0.1f) {
            _groundFriction.grounds[x].sidewaysFriction = 0.8f;
          }
          if (_groundFriction.grounds[x].torqueInThisGround < 0.05f) {
            _groundFriction.grounds[x].torqueInThisGround = 1.0f;
          }
        }
      }

      //skidmarks
      if (_skidMarks != null) {
        for (int x = 0; x < _skidMarks.otherGround.Length; x++) {
          Color testColor = new Color(0, 0, 0, 0);
          if (_skidMarks.otherGround[x].color == testColor) {
            _skidMarks.otherGround[x].color = new Color(0.2f, 0.1f, 0.0f, 0.9f);
          }
          if (_skidMarks.otherGround[x].opacity < 0.1f) {
            _skidMarks.otherGround[x].opacity = 0.7f;
          }
        }
      }

      //fuel
      if (_fuel != null) {
        _fuel.startingFuel = Mathf.Clamp(_fuel.startingFuel, 0, _fuel.capacityInLiters);
      }

      //torque
      if (_vehicleTorque != null) {
        _vehicleTorque.engineTorque = Mathf.Clamp(_vehicleTorque.engineTorque, 0.1f, 10.0f);
      }

      //others
      if (_additionalFeatures != null) {
        _additionalFeatures.additionalNitroTorque = Mathf.Clamp(_additionalFeatures.additionalNitroTorque, 1.1f, 3.5f);
        _additionalFeatures.nitroTime = Mathf.Clamp(_additionalFeatures.nitroTime, 3.0f, 25.0f);
        _additionalFeatures.rechargeSpeed = Mathf.Clamp(_additionalFeatures.rechargeSpeed, 0.05f, 2.0f);
      }

      // wheelMeshes on wheelCollider variable
      if (_wheels != null) {
        WheelCollider tempCollider = null;
        if (_wheels.rightFrontWheel.wheelMesh) { //rightFrontWheel
          tempCollider = _wheels.rightFrontWheel.wheelMesh.transform.GetComponentInChildren<WheelCollider>();
          if (tempCollider) {
            Debug.LogError("You have associated an object that contains the 'wheelCollider' component in the '" + transform.name + " > Wheels> RightFrontWheel> WheelMesh' variable, and this can cause problems. Associate only objects that have meshes in this variable.");
            tempCollider = null;
          }
        }
        if (_wheels.leftFrontWheel.wheelMesh) { //leftFrontWheel
          tempCollider = _wheels.leftFrontWheel.wheelMesh.transform.GetComponentInChildren<WheelCollider>();
          if (tempCollider) {
            Debug.LogError("You have associated an object that contains the 'wheelCollider' component in the '" + transform.name + " > Wheels> LeftFrontWheel> WheelMesh' variable, and this can cause problems. Associate only objects that have meshes in this variable.");
            tempCollider = null;
          }
        }
        if (_wheels.rightRearWheel.wheelMesh) { //rightRearWheel
          tempCollider = _wheels.rightRearWheel.wheelMesh.transform.GetComponentInChildren<WheelCollider>();
          if (tempCollider) {
            Debug.LogError("You have associated an object that contains the 'wheelCollider' component in the '" + transform.name + " > Wheels> RightRearWheel> WheelMesh' variable, and this can cause problems. Associate only objects that have meshes in this variable.");
            tempCollider = null;
          }
        }
        if (_wheels.leftRearWheel.wheelMesh) { //leftRearWheel
          tempCollider = _wheels.leftRearWheel.wheelMesh.transform.GetComponentInChildren<WheelCollider>();
          if (tempCollider) {
            Debug.LogError("You have associated an object that contains the 'wheelCollider' component in the '" + transform.name + " > Wheels> LeftRearWheel> WheelMesh' variable, and this can cause problems. Associate only objects that have meshes in this variable.");
            tempCollider = null;
          }
        }
        for (int x = 0; x < _wheels.extraWheels.Length; x++) { //extra wheels
          if (_wheels.extraWheels[x].wheelMesh) {
            tempCollider = _wheels.extraWheels[x].wheelMesh.transform.GetComponentInChildren<WheelCollider>();
            if (tempCollider) {
              Debug.LogError("You have associated an object that contains the 'wheelCollider' component in the '" + transform.name + " > Wheels> ExtraWheels[" + x + "] > WheelMesh' variable, and this can cause problems. Associate only objects that have meshes in this variable.");
              tempCollider = null;
            }
          }
        }
      }
    }
#endif

    void OnEnable() {
      _error = false;

      //null by default
      _vehicleState = ControlState.isNull;

      //check wheels
      if (!_wheels.rightFrontWheel.wheelCollider || !_wheels.leftFrontWheel.wheelCollider || !_wheels.rightRearWheel.wheelCollider || !_wheels.leftRearWheel.wheelCollider) {
        Debug.LogError("The vehicle " + transform.name + " must have at least the four main wheels associated with its variables, within class '_wheels'.");
        _error = true;
        this.transform.gameObject.SetActive(false);
        return;
      }

      hornIsOn = false;
      youCanCall = true;
      previousDelayStartEngine = _vehicleSettings.delayToStartTheEngine;

      //'Configure Vehicle Substeps' temporarily sets parameters, and is rebooting when a vehicle is deactivated, so it needs to be reconfigured when it is enabled.
      WheelCollider WheelColliders = GetComponentInChildren<WheelCollider>();
      if (WheelColliders) {
        WheelColliders.ConfigureVehicleSubsteps(substeps.speedThreshold, substeps.stepsBelowThreshold, substeps.stepsAboveThreshold);
      }

      //get Active Terrain
      if (!activeTerrain_optional) {
        activeTerrain_optional = Terrain.activeTerrain;
      }
    }

    void Start() {
      if (!_error) {
        enableLightsOnStart = _lights.enableLights;
        enableSkidMarksOnStart = _skidMarks.enableSkidMarks;
        enableParticlesOnStart = _particles.enableParticles;

        SetValues();
        SetWheelCollidersOnStart();
        DisableParticles();

        // lights
        msvs_useExtraLights = msvs_useHeadLights = msvs_useMainLights = msvs_useWarningOrFlashingLights = false;
        DisableAllLightsOnStart();
        if (enableLightsOnStart) {
          SetLightValuesStart();
        }

        //skid marks
        if (skidMarksShader) {
          if (enableSkidMarksOnStart) {
            SetSkidMarksValues();
          }
        } else {
          enableSkidMarksOnStart = false;
        }
      }
    }
    void Update() {
      KMh = ms_Rigidbody.velocity.magnitude * 3.6f;
      DiscoverAverageRpm();

      //engine DIES
      if (_vehicleSettings.engineDie) {
        if (_vehicleState == ControlState.isPlayer && theEngineIsRunning) {
          if (!automaticGears && currentGear > 0) {
            if (wheelFDIsGrounded && wheelFEIsGrounded && wheelTDIsGrounded && wheelTEIsGrounded) {

              float tempPoint_EvaluateFactor = KMh / _vehicleTorque.speedOfGear;
              float existingTorque = Mathf.Abs(_vehicleTorque.gearsArray[currentGear - 1].Evaluate(tempPoint_EvaluateFactor));

              float minimumRPM = _vehicleSettings.minVehicleRPM * 1.2f;
              if (Mathf.Clamp01(verticalInput) > 0.5f && _vehicleSettings.vehicleRPMValue < minimumRPM) {
                float conditionRPM = (15.0f / averageWheelRadius);
                if (existingTorque < 0.03f || mediumRPM < -conditionRPM) { // to currentGear >= 1 
                  ms_Rigidbody.AddTorque(0.5f * ms_Rigidbody.mass * transform.right, ForceMode.Impulse);
                  previousDelayStartEngine = _vehicleSettings.delayToStartTheEngine;
                  _vehicleSettings.delayToStartTheEngine = 2;
                  StartCoroutine(nameof(StartEngineCoroutine), false);
                }
              }
            }
          }
        }
      }

      //turn on and turn off
      if (_vehicleState == ControlState.isNull && theEngineIsRunning) {
        StartCoroutine(nameof(StartEngineCoroutine), false);
      }
      if (_vehicleState == ControlState.isPlayer) {
        float limit = 0.5f;
        if (Mathf.Abs(verticalInput) > limit && !theEngineIsRunning && _vehicleSettings.turnOnWhenAccelerating && youCanCall) {
          if (currentFuelLiters > 0) {
            enableEngineSound = true;
            if (_sounds.engineSound) {
              engineSoundAUD.pitch = 0.5f;
              pitchAUDforRPM = 0.7f;
            }
            if (_sounds.engineStartSound) {
              previousDelayStartEngine = _vehicleSettings.delayToStartTheEngine;
              _vehicleSettings.delayToStartTheEngine = Mathf.Abs(_sounds.engineStartSound.length - _sounds.engineStartSound.length * 0.3f);
              engineSoundAUD.volume = 0;
              engineStartSoundAUD.PlayOneShot(engineStartSoundAUD.clip);
            }
            //
            StartCoroutine(nameof(StartEngineCoroutine), true);
          }
        }
      }

      //VEHICLE NITRO
      if (theEngineIsRunning && (_vehicleState == ControlState.isPlayer)) {
        NitroFunction();
      } else {
        _additionalFeatures.nitroIsTrueVar = false;
        _additionalFeatures.canUseNitro = false;
      }

      VehicleSoundsFunction();

      if (enableLightsOnStart) { //if false, mobile buttons is off automatically
        LightsManager();
      }

      UpdateWheelMeshes();

      //particles
      ParticlesEmitter();

      //gears
      if (_vehicleState == ControlState.isPlayer) {
        if (automaticGears) {
          AutomaticGears();
        }
      }
      //
      VehicleRPMFunction();
      FuelManager();
      SpeedometerAndOthers();
    }
    void FixedUpdate() {
      CheckGroundedWheelsOnFixedUpdate();

      //fixedDeltaTime
      fixedDeltaTime = Time.fixedDeltaTime;
      if (fixedDeltaTime < 0.0001f || fixedDeltaTime > 1) {
        fixedDeltaTime = 0.02f;
      }

      if (_vehicleState == ControlState.isPlayer) {
        VehicleSteeringWheel();
        //set vehicle heigth (Move Towards)
        if (_suspension.vehicleCustomHeights.Length > 0) {
          SetGeneralSuspensionHeight();
        }
      }

      //motor brake
      StabilizeMotorBrakeForce();

      //forces factor
      inclinationFactorForcesDown = Mathf.Clamp(Mathf.Abs(Vector3.Dot(Vector3.up, transform.up)), _vehiclePhysicStabilizers.downForceAngleFactor, 1.0f);

      if (KMh > 0.1f) {
        //set friction on wheels
        if (_groundFriction.grounds.Length > 0) {
          SetWheelCollidersFrictionFixedUpdate(_wheels.rightFrontWheel.wheelCollider);
          SetWheelCollidersFrictionFixedUpdate(_wheels.leftFrontWheel.wheelCollider);
          SetWheelCollidersFrictionFixedUpdate(_wheels.rightRearWheel.wheelCollider);
          SetWheelCollidersFrictionFixedUpdate(_wheels.leftRearWheel.wheelCollider);
          for (int x = 0; x < _wheels.extraWheels.Length; x++) {
            SetWheelCollidersFrictionFixedUpdate(_wheels.extraWheels[x].wheelCollider);
          }
        }
        //stabilizers
        StabilizeVehicleRollForces();
        StabilizeVehicleRotation();
        StabilizeAngularRotation();
        StabilizeAirRotation();
        //drag
        if (_vehiclePhysicStabilizers.rigidbodyMaxDrag > 0.01f) {
          ms_Rigidbody.drag = Mathf.Clamp((KMh / _vehicleTorque.maxVelocityKMh) * 0.2f, 0.001f, _vehiclePhysicStabilizers.rigidbodyMaxDrag);
        }
      }

      //torque and brake
      ApplyTorque();
      Brakes();
      //

      //extra gravity
      if (_vehiclePhysicStabilizers.extraGravity > 0) {
        ms_Rigidbody.AddForce(Vector3.down * _vehiclePhysicStabilizers.extraGravity * _vehicleSettings.vehicleMass);
      }

      //down Force
      if (groundedWheels > 0) {
        float lerpNextValue = _vehiclePhysicStabilizers.vehicleDownForce * _vehicleSettings.vehicleMass * inclinationFactorForcesDown;
        downForceFixedUpdateRef = Mathf.Lerp(downForceFixedUpdateRef, lerpNextValue, fixedDeltaTime * 2.5f);
      } else {
        downForceFixedUpdateRef = Mathf.Lerp(downForceFixedUpdateRef, 0, fixedDeltaTime * 2.5f);
      }
      ms_Rigidbody.AddForce(-transform.up * downForceFixedUpdateRef);

      //tire slips
      if (_vehiclePhysicStabilizers.stabilizeTireSlips) {
        if (_vehicleState == ControlState.isPlayer || KMh > 0.1f) {
          SetWheelForces(_wheels.rightFrontWheel.wheelCollider);
          SetWheelForces(_wheels.leftFrontWheel.wheelCollider);
          SetWheelForces(_wheels.rightRearWheel.wheelCollider);
          SetWheelForces(_wheels.leftRearWheel.wheelCollider);
          for (int x = 0; x < _wheels.extraWheels.Length; x++) {
            SetWheelForces(_wheels.extraWheels[x].wheelCollider);
          }
        }
      }

      //Reverse force
      if (_vehiclePhysicStabilizers.airDrag > 0.05f && KMh > 0.1f) {
        if (verticalInput == 0) {
          if (reverseForceTimer < 3.1f) {
            reverseForceTimer += fixedDeltaTime;
          }
        } else {
          reverseForceTimer = 0.0f;
        }
        //
        if (KMh > 2 && reverseForceTimer > 2.0f) {
          Vector3 reverseForceVector = -transform.forward * _vehicleSettings.vehicleMass * _vehiclePhysicStabilizers.airDrag * Mathf.Clamp(mediumRPM, -1, 1);
          ms_Rigidbody.AddForce(reverseForceVector);
        }
      } else {
        reverseForceTimer = 0.0f;
      }
      //

      //brakes ABS
      if (_vehicleState == ControlState.isPlayer) {
        if (_brakes.ABS && isBraking) {
          if (wheelFDIsGrounded && wheelFEIsGrounded && wheelTDIsGrounded && wheelTEIsGrounded) {
            if (_brakes.brakeSlowly) {
              absLerpFactor = Mathf.Lerp(absLerpFactor, 1, fixedDeltaTime * _brakes.speedBrakeSlowly);
            } else {
              absLerpFactor = 1;
            }
            float absSpeedFactor = Mathf.Clamp(KMh, 70, 150);
            //
            float absBrakeInput = 0.0f;
            if (automaticGears) {
              if (currentGear > 0 && mediumRPM > 0) {
                absBrakeInput = Mathf.Abs(Mathf.Clamp(verticalInput, -1.0f, 0.0f));
              } else if (currentGear <= 0 && mediumRPM < 0) {
                absBrakeInput = Mathf.Abs(Mathf.Clamp(verticalInput, 0.0f, 1.0f)) * -1;
              }
              //
              Vector3 absTotalForce = (-transform.forward * absSpeedFactor * _vehicleSettings.vehicleMass * _brakes.ABSForce * absBrakeInput * absLerpFactor);
              ms_Rigidbody.AddForce(absTotalForce);
            } else {
              if (currentGear > 0 && mediumRPM > 0) {
                absBrakeInput = Mathf.Abs(Mathf.Clamp(verticalInput, -1.0f, 0.0f));
              } else if (currentGear <= 0 && mediumRPM < 0) {
                absBrakeInput = Mathf.Abs(Mathf.Clamp(verticalInput, -1.0f, 0.0f)) * -1.0f;
              } else if (currentGear >= 0 && mediumRPM < 0) {
                absBrakeInput = Mathf.Abs(Mathf.Clamp(verticalInput, -1.0f, 0.0f)) * -1.0f;
              } else if (currentGear <= 0 && mediumRPM > 0) {
                absBrakeInput = Mathf.Abs(Mathf.Clamp(verticalInput, -1.0f, 0.0f));
              }
              //
              Vector3 absTotalForce = (-transform.forward * absSpeedFactor * _vehicleSettings.vehicleMass * _brakes.ABSForce * absBrakeInput * absLerpFactor);
              ms_Rigidbody.AddForce(absTotalForce);
            }
          }
        } else {
          if (KMh > 2.5f) {
            absLerpFactor = 0.0f;
          } else {
            absLerpFactor = Mathf.Lerp(absLerpFactor, 1, fixedDeltaTime * 3.0f);
          }
        }
      }
    }
    void LateUpdate() {
      //skid marks
      if (enableSkidMarksOnStart) {
        if (KMh > 0.01f) {
          CheckGroundForSKidMarks();
        } else {
          _wheels.rightFrontWheel.generateSkidBool = false;
          _wheels.leftFrontWheel.generateSkidBool = false;
          _wheels.rightRearWheel.generateSkidBool = false;
          _wheels.leftRearWheel.generateSkidBool = false;
          for (int x = 0; x < _wheels.extraWheels.Length; x++) {
            _wheels.extraWheels[x].generateSkidBool = false;
          }
        }
      }
    }
    void OnCollisionStay() {
      colliding = true;
    }
    void OnCollisionExit() {
      colliding = false;
    }

    public void DisableParticles() {
      //NITRO
      if (_particles.nitroParticles.Length > 0) {
        for (int x = 0; x < _particles.nitroParticles.Length; x++) {
          if (_particles.nitroParticles[x]) {
            ParticleSystem.MainModule particleNitroMainModule = _particles.nitroParticles[x].main;
            particleNitroMainModule.playOnAwake = false;
            _particles.nitroParticles[x].Stop(true);
            //
            ParticleSystem.EmissionModule tempParticleNitro = _particles.nitroParticles[x].emission;
            tempParticleNitro.rateOverTime = 10;
            tempParticleNitro.enabled = false;
          }
        }
      }
      //
      //
      //exhaustSmoke
      if (_particles.exhaustSmoke.Length > 0) {
        for (int x = 0; x < _particles.exhaustSmoke.Length; x++) {
          if (_particles.exhaustSmoke[x].smoke) {
            ParticleSystem.EmissionModule particleTemp = _particles.exhaustSmoke[x].smoke.emission;
            particleTemp.rateOverTime = 1;

            ParticleSystem.MainModule particleMainModule = _particles.exhaustSmoke[x].smoke.main;
            particleMainModule.startSpeed = 1.5f;
            particleMainModule.playOnAwake = true;
            _particles.exhaustSmoke[x].smoke.Play(true);
            //
            if (!enableParticlesOnStart) {
              particleTemp = _particles.exhaustSmoke[x].smoke.emission;
              particleTemp.enabled = false;
            }
          }
        }
      }
      //
      //dust particle
      if (wheelDustParticle) {
        if (_groundParticles.Length > 0) {
          for (int x = 0; x < _groundParticles.Length; x++) {
            for (int y = 0; y < wheelColliderList.Length; y++) {
              //generate particle and position
              ParticleSystem tempParticleInstance = Instantiate(wheelDustParticle) as ParticleSystem;
              _groundParticles[x].wheelDustList.Add(tempParticleInstance);
              _groundParticles[x].wheelDustList[y].transform.parent = wheelColliderList[y].transform;
              _groundParticles[x].wheelDustList[y].transform.localPosition = new Vector3(0, -wheelColliderList[y].radius, 0);

              //get particle
              ParticleSystem.EmissionModule particleTemp = _groundParticles[x].wheelDustList[y].emission;
              ParticleSystem.MainModule particleMainModule = _groundParticles[x].wheelDustList[y].main;

              //set emission rate 
              particleTemp.rateOverTime = 1;

              //set color
              particleMainModule.startColor = _groundParticles[x].particleColor;
              if (particleMainModule.startColor.color.a == 0) {
                Color newColor = new Color(_groundParticles[x].particleColor.r, _groundParticles[x].particleColor.g, _groundParticles[x].particleColor.b, 1.0f);
                particleMainModule.startColor = newColor;
              }

              //disable paraticle
              particleMainModule.playOnAwake = false;
              //_groundParticles [x].wheelDustList [y].Stop (true);
              if (!_groundParticles[x].wheelDustList[y].isPlaying) {
                _groundParticles[x].wheelDustList[y].Play(true);
              }
              particleTemp.enabled = false;
            }
          }
        }
      }
    }
    void SetValues() {
      vehicleScale = transform.lossyScale.y;
      _suspension.constVehicleHeightStart = _suspension.vehicleStartHeight;
      _suspension.indexCustomSuspensionHeight = 0;
      reverseForceTimer = 0.0f;

      //speedometer
      if (_speedometer._speedometerModel1__ScreenSpace.canvas_Gauges) {
        _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.enabledGauge = false;
        _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.enableNitroBar = _additionalFeatures.useNitro;
      }
      if (_speedometer._speedometerModel2__WorldSpace.masterObject) {
        if (_speedometer._speedometerModel2__WorldSpace.speedometerSpeedPointer) {
          speedPointerStartRotation = _speedometer._speedometerModel2__WorldSpace.speedometerSpeedPointer.transform.localEulerAngles;
        }
        if (_speedometer._speedometerModel2__WorldSpace.speedometerRPMPointer) {
          rpmPointerStartRotation = _speedometer._speedometerModel2__WorldSpace.speedometerRPMPointer.transform.localEulerAngles;
        }
        if (_speedometer._speedometerModel2__WorldSpace.speedometerFuelPointer) {
          fuelPointerStartRotation = _speedometer._speedometerModel2__WorldSpace.speedometerFuelPointer.transform.localEulerAngles;
        }
        if (_speedometer._speedometerModel2__WorldSpace.gearText) {
          _speedometer._speedometerModel2__WorldSpace.gearText.text = "D0";
        }
        if (_speedometer._speedometerModel2__WorldSpace.nitroBar_filled) {
          _speedometer._speedometerModel2__WorldSpace.nitroBar_filled.type = Image.Type.Filled;
          _speedometer._speedometerModel2__WorldSpace.nitroBar_filled.fillAmount = 1;
        }
      }

      //skidMarks
      switch (_skidMarks.maxTrailLength) {
        case VehicleSkidMarksClass.SizeEnum._600: CacheSize = 600; break;
        case VehicleSkidMarksClass.SizeEnum._1200: CacheSize = 1200; break;
        case VehicleSkidMarksClass.SizeEnum._2400: CacheSize = 2400; break;
        case VehicleSkidMarksClass.SizeEnum._4800: CacheSize = 4800; break;
        case VehicleSkidMarksClass.SizeEnum._7200: CacheSize = 7200; break;
        case VehicleSkidMarksClass.SizeEnum._9600: CacheSize = 9600; break;
      }
      vertices = new List<Vector3>(CacheSize);
      normals = new List<Vector3>(CacheSize);
      colors = new List<Color>(CacheSize);
      uv = new List<Vector2>(CacheSize);
      tris = new List<int>(CacheSize * 3);
      lastPoint = new Vector3[4 + _wheels.extraWheels.Length];

      //doors
      if (doorPosition.Length == 0) {
        doorPosition = new GameObject[1];
      }
      for (int x = 0; x < doorPosition.Length; x++) {
        if (!doorPosition[x]) {
          doorPosition[x] = new GameObject("doorPos");
          doorPosition[x].transform.position = transform.position;
        }
        doorPosition[x].transform.rotation = transform.rotation;
        doorPosition[x].transform.parent = transform;
      }

      //wheel list
      wheelColliderList = new WheelCollider[(4 + _wheels.extraWheels.Length)];
      wheelColliderList[0] = _wheels.rightFrontWheel.wheelCollider;
      wheelColliderList[1] = _wheels.leftFrontWheel.wheelCollider;
      wheelColliderList[2] = _wheels.rightRearWheel.wheelCollider;
      wheelColliderList[3] = _wheels.leftRearWheel.wheelCollider;
      for (int x = 0; x < _wheels.extraWheels.Length; x++) {
        wheelColliderList[x + 4] = _wheels.extraWheels[x].wheelCollider;
      }

      //mediumRadius
      float sumR = 0;
      for (int x = 0; x < wheelColliderList.Length; x++) {
        sumR += wheelColliderList[x].radius;
      }
      averageWheelRadius = sumR / wheelColliderList.Length;
      averageWheelRadius = Mathf.Clamp(averageWheelRadius, 0.01f, 10.0f);

      //fuel
      _fuel.startingFuel = Mathf.Clamp(_fuel.startingFuel, 0, _fuel.capacityInLiters);
      currentFuelLiters = _fuel.startingFuel;

      //steering wheel
      volantDistortion = Random.Range(-0.1f, 0.1f);
      while (volantDistortion >= -0.025f && volantDistortion <= 0.025f) {
        volantDistortion = Random.Range(-0.1f, 0.1f);
      }

      boolTimeAirBrake = windLoop = loopBlinkersOn = hornIsOn = false;
      handBrakeTrue = _vehicleSettings.startBraking;
      changinGears = false;

      //start engine or not
      enableEngineSound = false;
      //theEngineIsRunning = false;
      youCanCall = true;
      previousDelayStartEngine = _vehicleSettings.delayToStartTheEngine;

      //vehicle rigidbody
      ms_Rigidbody = GetComponent<Rigidbody>();
      ms_Rigidbody.useGravity = true;
      ms_Rigidbody.mass = _vehicleSettings.vehicleMass;
      ms_Rigidbody.drag = 0.0f;
      ms_Rigidbody.angularDrag = 0.05f;
      ms_Rigidbody.maxAngularVelocity = 14.0f;
      ms_Rigidbody.maxDepenetrationVelocity = 8.0f;
      ms_Rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
      ms_Rigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;

      //configure vehicle substeps on start
      WheelCollider WheelColliders = GetComponentInChildren<WheelCollider>();
      WheelColliders.ConfigureVehicleSubsteps(substeps.speedThreshold, substeps.stepsBelowThreshold, substeps.stepsAboveThreshold);

      //center of mass
      if (_vehiclePhysicStabilizers.centerOfMass) {
        ms_Rigidbody.centerOfMass = transform.InverseTransformPoint(_vehiclePhysicStabilizers.centerOfMass.position);
      } else {
        ms_Rigidbody.centerOfMass = Vector3.zero;
      }

      //steeringAssist bugs
      Vector3 centerOfMassPosition = this.transform.TransformPoint(ms_Rigidbody.centerOfMass);
      float distRFrontWheel = Vector3.Distance(centerOfMassPosition, _wheels.rightFrontWheel.wheelCollider.transform.position);
      float distLFrontWheel = Vector3.Distance(centerOfMassPosition, _wheels.leftFrontWheel.wheelCollider.transform.position);
      float distRRearWheel = Vector3.Distance(centerOfMassPosition, _wheels.rightRearWheel.wheelCollider.transform.position);
      float distLRearWheel = Vector3.Distance(centerOfMassPosition, _wheels.leftRearWheel.wheelCollider.transform.position);
      float rightDistance = distRFrontWheel + distRRearWheel;
      float leftDistance = distLFrontWheel + distLRearWheel;
      if (Mathf.Abs(rightDistance - leftDistance) > 0.015f) {
        Debug.LogWarning("The vehicle '" + this.transform.name + "' has its wheels misaligned relative to the center of mass of the vehicle. This can cause problems in the stability of the vehicle. It is recommended to align the wheels of the vehicle to its center of mass, or, leave the variable 'SteeringWheel> SteeringAssist' to 0. Leaving the center of mass perfectly aligned to the vehicle is also important for a realistic simulation.");
        _steeringWheel.steeringAssist *= 0.5f;
      }

      //steering wheel
      if (_steeringWheel.steeringWheelObject) {
        switch (_steeringWheel.rotationType) {
          case VolantSettingsClass.SelectRotation.RotationInY:
            volantStartRotation = _steeringWheel.steeringWheelObject.transform.localEulerAngles.y;
            break;
          case VolantSettingsClass.SelectRotation.RotationInZ:
            volantStartRotation = _steeringWheel.steeringWheelObject.transform.localEulerAngles.z;
            break;
        }
      }

      //additional settings
      if (_additionalFeatures.useNitro) {
        _additionalFeatures.timerNitro = _additionalFeatures.nitroTime;
        _additionalFeatures.nitroIsTrueInput = false;
        _additionalFeatures.nitroIsTrueVar = false;
        _additionalFeatures.canUseNitro = true;
      }

      //rpm animation curve
      _vehicleSettings.rpmCurve = new AnimationCurve(new Keyframe(0.85f, _vehicleSettings.minVehicleRPM), new Keyframe(_sounds.speedOfEngineSound + 0.15f, _vehicleSettings.maxVehicleRPM));

      //sounds
      speedLerpSound = 5;
      wheelEmitterSoundX = new int[_groundSounds.groundSounds.Length];
      wheelBlockSoundX = new int[_groundSounds.groundSounds.Length];
      wheelEmitterSoundXSkid = new int[_groundSounds.groundSounds.Length];
      wheelBlockSoundXSkid = new int[_groundSounds.groundSounds.Length];
      //
      GameObject vehicleSoundsMainObject = new GameObject("VehicleSounds");
      vehicleSoundsMainObject.transform.position = transform.position;
      vehicleSoundsMainObject.transform.parent = transform;
      if (_sounds.engineSound) {
        engineSoundAUD = GenerateAudioSource("Sound of engine", 10, 0, _sounds.engineSound, true, true, true, vehicleSoundsMainObject, 4.5f, 500);
        if (_sounds.engineSoundPosition) {
          _sounds.engineSoundPosition.parent = vehicleSoundsMainObject.transform;
          engineSoundAUD.transform.position = _sounds.engineSoundPosition.position;
        }
      }
      if (_sounds.engineStartSound) {
        engineStartSoundAUD = GenerateAudioSource("Engine start sound", 10, 1, _sounds.engineStartSound, false, false, false, vehicleSoundsMainObject, 4.5f, 250);
      }
      if (_sounds.blinkingSound) {
        flashingSoundAUD = GenerateAudioSource("Blinking Sound", 10, 1, _sounds.blinkingSound, true, true, false, vehicleSoundsMainObject, 4.5f, 500);
        flashingSoundAUD.Stop();
        loopBlinkersOn = false;
      }
      if (_sounds.hornSound) {
        hornSoundAUD = GenerateAudioSource("Sound of horn", 10, 1, _sounds.hornSound, false, false, false, vehicleSoundsMainObject, 10, 500);
      }
      if (_sounds.reverseSirenSound) {
        sirenSoundAUD = GenerateAudioSource("Sound of siren", 10, 1, _sounds.reverseSirenSound, true, false, false, vehicleSoundsMainObject, 5, 100);
      }
      if (_sounds.handBrakeSound) {
        handBrakeSoundAUD = GenerateAudioSource("Sound of hand brake", 10, 0.6f, _sounds.handBrakeSound, false, false, false, vehicleSoundsMainObject, 4.5f, 100);
        handBrakeSoundWasPlayed = false;
      }
      if (_sounds.nitroStartSound) {
        nitroSoundAUD = GenerateAudioSource("Nitro sound", 10, 1, _sounds.nitroStartSound, true, false, false, vehicleSoundsMainObject, 4.5f, 50);
        nitroSoundWasPlayed = false;
      }
      if (_sounds.airBrakeSound) {
        airBrakeSoundAUD = GenerateAudioSource("Sound of air brake", 10, _sounds.volumeAirBrakeSound, _sounds.airBrakeSound, false, false, false, vehicleSoundsMainObject, 5, 200);
      }
      if (_sounds.wheelImpactSound) {
        beatsOnWheelSoundAUD = GenerateAudioSource("Sound of wheel beats", 10, _sounds.volumeWheelImpact, _sounds.wheelImpactSound, false, false, false, vehicleSoundsMainObject, 5, 100);
      }
      if (_sounds.windSound) {
        windSoundAUD = GenerateAudioSource("Sound of wind", 10, 0.0f, _sounds.windSound, true, false, false, vehicleSoundsMainObject, 10, 100);
      }
      if (_groundSounds.standardSkidSound) {
        skiddingSoundAUD = GenerateAudioSource("Sound of skid", 10, 1, _groundSounds.standardSkidSound, false, false, false, vehicleSoundsMainObject, 10, 500);
      }
      if (_sounds.collisionSounds.Length > 0) {
        if (_sounds.collisionSounds[0]) {
          beatsSoundAUD = GenerateAudioSource("Sound of beats", 10, _sounds.volumeCollisionSounds, _sounds.collisionSounds[UnityEngine.Random.Range(0, _sounds.collisionSounds.Length)], false, false, false, vehicleSoundsMainObject, 10, 500);
        }
      }
      groundSoundsAUD = new AudioSource[_groundSounds.groundSounds.Length];
      if (_groundSounds.groundSounds.Length > 0) {
        for (int x = 0; x < _groundSounds.groundSounds.Length; x++) {
          if (_groundSounds.groundSounds[x].groundSound) {
            groundSoundsAUD[x] = GenerateAudioSource("GroundSounds" + x, 10, _groundSounds.groundSounds[x].volumeSound, _groundSounds.groundSounds[x].groundSound, true, false, false, vehicleSoundsMainObject, 10, 500);
          }
        }
      }
      groundSoundsAUDSkid = new AudioSource[_groundSounds.groundSounds.Length];
      if (_groundSounds.groundSounds.Length > 0) {
        for (int x = 0; x < _groundSounds.groundSounds.Length; x++) {
          if (_groundSounds.groundSounds[x].skiddingSound) {
            groundSoundsAUDSkid[x] = GenerateAudioSource("GroundSoundsSkid" + x, 10, _groundSounds.groundSounds[x].volumeSkid, _groundSounds.groundSounds[x].skiddingSound, true, false, false, vehicleSoundsMainObject, 10, 500);
          }
        }
      }


      //wheel impact sound
      Vector3 posWheel;
      Quaternion rotWheel;
      //rightFrontWheel
      _wheels.rightFrontWheel.wheelCollider.GetWorldPose(out posWheel, out rotWheel);
      lastRightFrontPositionY = transform.InverseTransformPoint(posWheel).y;
      //leftFrontWheel
      _wheels.leftFrontWheel.wheelCollider.GetWorldPose(out posWheel, out rotWheel);
      lastLeftFrontPositionY = transform.InverseTransformPoint(posWheel).y;
      //rightRearWheel
      _wheels.rightRearWheel.wheelCollider.GetWorldPose(out posWheel, out rotWheel);
      lastRightRearPositionY = transform.InverseTransformPoint(posWheel).y;
      //leftRearWheel
      _wheels.leftRearWheel.wheelCollider.GetWorldPose(out posWheel, out rotWheel);
      lastLeftRearPositionY = transform.InverseTransformPoint(posWheel).y;

      sensImpactFR = (0.25f - _sounds.sensibilityWheelImpact) * (2.65f * _wheels.rightFrontWheel.wheelCollider.radius);
      sensImpactFL = (0.25f - _sounds.sensibilityWheelImpact) * (2.65f * _wheels.leftFrontWheel.wheelCollider.radius);
      sensImpactRR = (0.25f - _sounds.sensibilityWheelImpact) * (2.65f * _wheels.rightRearWheel.wheelCollider.radius);
      sensImpactRL = (0.25f - _sounds.sensibilityWheelImpact) * (2.65f * _wheels.leftRearWheel.wheelCollider.radius);

      //extra wheels
      sensImpactExtraWheels = new float[_wheels.extraWheels.Length];
      lastPositionYExtraWheels = new float[_wheels.extraWheels.Length];
      for (int x = 0; x < _wheels.extraWheels.Length; x++) {
        sensImpactExtraWheels[x] = (0.25f - _sounds.sensibilityWheelImpact) * (2.65f * _wheels.extraWheels[x].wheelCollider.radius);
        _wheels.extraWheels[x].wheelCollider.GetWorldPose(out posWheel, out rotWheel);
        lastPositionYExtraWheels[x] = transform.InverseTransformPoint(posWheel).y;
      }
    }




    public static float ClampAngle(float angle, float min, float max) {
      if (angle < -360F) { angle += 360F; }
      if (angle > 360F) { angle -= 360F; }
      return Mathf.Clamp(angle, min, max);
    }

    void SpeedometerAndOthers() { //On Update
      if (_speedometer._speedometerModel1__ScreenSpace.canvas_Gauges) {
        if (_vehicleState == ControlState.isPlayer) {
          //set parameters
          _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.vehicleMaxSpeed = _vehicleTorque.maxVelocityKMh;
          _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.vehicleMaxRPM = _vehicleSettings.maxVehicleRPM;
          _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.enabledGauge = true;
          float speedFactorModel1 = (KMh / _vehicleTorque.maxVelocityKMh);
          float rpmFactorModel1 = (_vehicleSettings.vehicleRPMValue / _vehicleSettings.maxVehicleRPM);
          if (theEngineIsRunning) {
            speedFactorSpeedometerModel1 = Mathf.Lerp(speedFactorSpeedometerModel1, speedFactorModel1, Time.deltaTime * 5);
            rpmFactorSpeedometerModel1 = Mathf.Lerp(rpmFactorSpeedometerModel1, rpmFactorModel1, Time.deltaTime * 5);
          } else {
            speedFactorSpeedometerModel1 = Mathf.Lerp(speedFactorSpeedometerModel1, 0, Time.deltaTime * 5);
            rpmFactorSpeedometerModel1 = Mathf.Lerp(rpmFactorSpeedometerModel1, 0, Time.deltaTime * 5);
          }
          //kmh
          if (groundedWheels > 0) {
            _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.vehicleKmh = (int)KMh;
            _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.vehiclePercentkmh = speedFactorSpeedometerModel1;
          }
          //rpm
          _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.vehicleCurrentRpm = (int)_vehicleSettings.vehicleRPMValue;
          _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.vehiclePercentrpm = rpmFactorSpeedometerModel1;
          //gear
          _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.vehicleCurrentGear = currentGear;
          _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.autoGears = automaticGears;
          //nitro
          _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.vehiclePercentNitro = _additionalFeatures.timerNitro / _additionalFeatures.nitroTime;
          //fuel
          _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.vehiclePercentFuel = 1 - ((Mathf.Clamp(currentFuelLiters, 0.00001f, 500)) / _fuel.capacityInLiters);
          //handBrake
          _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.handBrakeTrue = handBrakeTrue;

          //position and size
          if (_speedometer._speedometerModel1__ScreenSpace.setPositionViaCode) {
            _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.uiOffset = _speedometer._speedometerModel1__ScreenSpace._UIHorizontalOffset;
          }
          if (_speedometer._speedometerModel1__ScreenSpace.setSizeViaCode) {
            _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.uiScaler = _speedometer._speedometerModel1__ScreenSpace._UIScale;
          }
        } else {
          _speedometer._speedometerModel1__ScreenSpace.canvas_Gauges.enabledGauge = false;
        }
      }
      if (_speedometer._speedometerModel2__WorldSpace.masterObject) {
        if (_vehicleState == ControlState.isPlayer) {
          if (!_speedometer._speedometerModel2__WorldSpace.masterObject.activeInHierarchy) {
            _speedometer._speedometerModel2__WorldSpace.masterObject.SetActive(true);
          }

          // Get Values
          float speedFactorModel2 = (KMh / _vehicleTorque.maxVelocityKMh);
          float rpmFactorModel2 = (_vehicleSettings.vehicleRPMValue / _vehicleSettings.maxVehicleRPM);
          if (theEngineIsRunning) {
            speedFactorSpeedometerModel2 = Mathf.MoveTowards(speedFactorSpeedometerModel2, speedFactorModel2, Time.deltaTime);
            rpmFactorSpeedometerModel2 = Mathf.MoveTowards(rpmFactorSpeedometerModel2, rpmFactorModel2, Time.deltaTime);
          } else {
            speedFactorSpeedometerModel2 = Mathf.Lerp(speedFactorSpeedometerModel2, 0, Time.deltaTime * 5);
            rpmFactorSpeedometerModel2 = Mathf.Lerp(rpmFactorSpeedometerModel2, 0, Time.deltaTime * 5);
          }

          //Speed Pointer
          if (_speedometer._speedometerModel2__WorldSpace.speedometerSpeedPointer) {
            float sumSpeedAngle = Mathf.Clamp01(speedFactorSpeedometerModel2) * 270.0f * _speedometer._speedometerModel2__WorldSpace.speedPointerRotationFactor;
            if (_speedometer._speedometerModel2__WorldSpace.rotationAxisSPEED == SpeedometerModel2.RotType.RotationInY) {
              _speedometer._speedometerModel2__WorldSpace.speedometerSpeedPointer.transform.localEulerAngles = new Vector3(speedPointerStartRotation.x, speedPointerStartRotation.y - sumSpeedAngle, speedPointerStartRotation.z);
            } else if (_speedometer._speedometerModel2__WorldSpace.rotationAxisSPEED == SpeedometerModel2.RotType.RotationInZ) {
              _speedometer._speedometerModel2__WorldSpace.speedometerSpeedPointer.transform.localEulerAngles = new Vector3(speedPointerStartRotation.x, speedPointerStartRotation.y, speedPointerStartRotation.z - sumSpeedAngle);
            }
          }

          //RPM Pointer
          if (_speedometer._speedometerModel2__WorldSpace.speedometerRPMPointer) {
            float sumRPMAngle = Mathf.Clamp01(rpmFactorSpeedometerModel2) * 270.0f * _speedometer._speedometerModel2__WorldSpace.RPMPointerRotationFactor;
            if (_speedometer._speedometerModel2__WorldSpace.rotationAxisRPM == SpeedometerModel2.RotType.RotationInY) {
              _speedometer._speedometerModel2__WorldSpace.speedometerRPMPointer.transform.localEulerAngles = new Vector3(rpmPointerStartRotation.x, rpmPointerStartRotation.y - sumRPMAngle, rpmPointerStartRotation.z);
            } else if (_speedometer._speedometerModel2__WorldSpace.rotationAxisRPM == SpeedometerModel2.RotType.RotationInZ) {
              _speedometer._speedometerModel2__WorldSpace.speedometerRPMPointer.transform.localEulerAngles = new Vector3(rpmPointerStartRotation.x, rpmPointerStartRotation.y, rpmPointerStartRotation.z - sumRPMAngle);
            }
          }

          //FUEL Pointer
          if (_speedometer._speedometerModel2__WorldSpace.speedometerFuelPointer) {
            float percentageToDecrement = 1 - ((Mathf.Clamp(currentFuelLiters, 0.00001f, 500)) / _fuel.capacityInLiters);
            float sumFuelAngle = Mathf.Clamp01(percentageToDecrement) * 135.0f * _speedometer._speedometerModel2__WorldSpace.FuelPointerRotationFactor;
            if (_speedometer._speedometerModel2__WorldSpace.rotationAxisFUEL == SpeedometerModel2.RotType.RotationInY) {
              _speedometer._speedometerModel2__WorldSpace.speedometerFuelPointer.transform.localEulerAngles = new Vector3(fuelPointerStartRotation.x, fuelPointerStartRotation.y + sumFuelAngle, fuelPointerStartRotation.z);
            } else if (_speedometer._speedometerModel2__WorldSpace.rotationAxisFUEL == SpeedometerModel2.RotType.RotationInZ) {
              _speedometer._speedometerModel2__WorldSpace.speedometerFuelPointer.transform.localEulerAngles = new Vector3(fuelPointerStartRotation.x, fuelPointerStartRotation.y, fuelPointerStartRotation.z + sumFuelAngle);
            }
          }

          //GEAR Text
          if (_speedometer._speedometerModel2__WorldSpace.gearText) {
            if (currentGear >= 0) {
              _speedometer._speedometerModel2__WorldSpace.gearText.text = "D" + currentGear;
            } else {
              _speedometer._speedometerModel2__WorldSpace.gearText.text = "R";
            }
          }

          //NITRO BAR FILLED
          if (_additionalFeatures.useNitro) {
            if (_speedometer._speedometerModel2__WorldSpace.nitroBar_filled) {
              _speedometer._speedometerModel2__WorldSpace.nitroBar_filled.enabled = true;
              _speedometer._speedometerModel2__WorldSpace.nitroBar_filled.fillAmount = _additionalFeatures.timerNitro / _additionalFeatures.nitroTime;
            }
          } else {
            if (_speedometer._speedometerModel2__WorldSpace.nitroBar_filled) {
              _speedometer._speedometerModel2__WorldSpace.nitroBar_filled.enabled = false;
              _speedometer._speedometerModel2__WorldSpace.nitroBar_filled.fillAmount = 0;
            }
          }

          //
        } else {
          if (_speedometer._speedometerModel2__WorldSpace.masterObject.activeInHierarchy) {
            _speedometer._speedometerModel2__WorldSpace.masterObject.SetActive(false);
          }
        }
      }
    }
    void NitroFunction() {
      if (_additionalFeatures.useNitro) {
        if (_additionalFeatures.nitroIsTrueInput) {
          if (_additionalFeatures.canUseNitro) {
            if (_additionalFeatures.timerNitro > 0) {
              _additionalFeatures.nitroIsTrueVar = true;
              _additionalFeatures.timerNitro -= Time.deltaTime;
              if (_additionalFeatures.timerNitro < 0) {
                _additionalFeatures.timerNitro = 0.001f; //avoid division by 0
                _additionalFeatures.nitroIsTrueVar = false;
                _additionalFeatures.canUseNitro = false;
              }
            } else {
              _additionalFeatures.canUseNitro = false;
              _additionalFeatures.nitroIsTrueInput = false;
            }
          } else {
            _additionalFeatures.nitroIsTrueInput = false;
            _additionalFeatures.nitroIsTrueVar = false;
            _additionalFeatures.timerNitro += (Time.deltaTime * _additionalFeatures.rechargeSpeed);
            _additionalFeatures.timerNitro = Mathf.Clamp(_additionalFeatures.timerNitro, 0.001f, _additionalFeatures.nitroTime);
            if (_additionalFeatures.timerNitro > 1) {
              _additionalFeatures.canUseNitro = true;
            }
          }
        } else {
          _additionalFeatures.nitroIsTrueVar = false;
          _additionalFeatures.timerNitro += (Time.deltaTime * _additionalFeatures.rechargeSpeed);
          _additionalFeatures.timerNitro = Mathf.Clamp(_additionalFeatures.timerNitro, 0.001f, _additionalFeatures.nitroTime);
          if (_additionalFeatures.timerNitro > 1) {
            _additionalFeatures.canUseNitro = true;
          }
        }
      }
    }
    void VehicleRPMFunction() { //On Update
      if (theEngineIsRunning && (_vehicleState == ControlState.isPlayer)) {
        float maxSpeedCurrentGear = 0;
        if (currentGear == -1 || currentGear == 0) {
          maxSpeedCurrentGear = _vehicleTorque.maxVelocityGears[0] * _vehicleTorque.speedOfGear;
        } else {
          maxSpeedCurrentGear = _vehicleTorque.maxVelocityGears[currentGear - 1] * _vehicleTorque.speedOfGear;
        }

        float velxCurrentRPM = Mathf.Clamp(KMh, 0.1f, maxSpeedCurrentGear);
        float nextAUDRPMValue = (velxCurrentRPM / maxSpeedCurrentGear) * _sounds.speedOfEngineSound;

        // pitch RPM
        if (handBrakeTrue || currentGear == 0) {
          if (automaticGears) {
            nextAUDRPMValue = 0.85f + (Mathf.Abs(verticalInput) * _sounds.speedOfEngineSound * 0.8f);
          } else {
            nextAUDRPMValue = 0.85f + (Mathf.Clamp01(verticalInput) * _sounds.speedOfEngineSound * 0.8f);
          }
        }

        nextAUDRPMValue = Mathf.Clamp(nextAUDRPMValue, 0.85f, _sounds.speedOfEngineSound);
        pitchAUDforRPM = Mathf.MoveTowards(pitchAUDforRPM, nextAUDRPMValue, Time.deltaTime * 3.0f);

        if (pitchAUDforRPM > (_sounds.speedOfEngineSound * 0.95f) && Mathf.Abs(verticalInput) > 0.25f) {
          pitchAUDforRPM = _sounds.speedOfEngineSound * 0.85f;
          lastKnownTorque *= 0.5f;
        }

        //set RPM value
        _vehicleSettings.vehicleRPMValue = _vehicleSettings.rpmCurve.Evaluate(pitchAUDforRPM);
        //

        // RPM by TORQUE -- aditional torque (finalTorque = torque + rpmTorqueFactor*torque)
        if (_vehicleTorque.rpmAffectsTheTorque > 0.25f) {
          if (Mathf.Abs(verticalInput) > 0.9f) {
            if (handBrakeTrue || currentGear == 0) {
              rpmTorqueFactor = Mathf.Lerp(rpmTorqueFactor, _vehicleTorque.rpmAffectsTheTorque, Time.deltaTime * 2.5f);
            } else {
              rpmTorqueFactor = Mathf.Lerp(rpmTorqueFactor, 0.0f, Time.deltaTime * 1.5f);
            }
          } else {
            rpmTorqueFactor = Mathf.Lerp(rpmTorqueFactor, 0.0f, Time.deltaTime * 1.5f);
          }
        } else {
          rpmTorqueFactor = 0.0f;
        }
        //
      } else {
        if (enableEngineSound) {
          pitchAUDforRPM = 0.7f;
        } else {
          pitchAUDforRPM = 0;
          _vehicleSettings.vehicleRPMValue = Mathf.Lerp(_vehicleSettings.vehicleRPMValue, 0.0f, Time.deltaTime * 10);
        }
        rpmTorqueFactor = 0;
      }
    }
    void DiscoverAverageRpm() {
      float sumRPM = 0;
      _wheels.rightFrontWheel.wheelColliderRPM = _wheels.rightFrontWheel.wheelCollider.rpm;
      if (wheelFDIsGrounded) {
        sumRPM += _wheels.rightFrontWheel.wheelColliderRPM;
      }
      //
      _wheels.leftFrontWheel.wheelColliderRPM = _wheels.leftFrontWheel.wheelCollider.rpm;
      if (wheelFEIsGrounded) {
        sumRPM += _wheels.leftFrontWheel.wheelColliderRPM;
      }
      //
      _wheels.rightRearWheel.wheelColliderRPM = _wheels.rightRearWheel.wheelCollider.rpm;
      if (wheelTDIsGrounded) {
        sumRPM += _wheels.rightRearWheel.wheelColliderRPM;
      }
      //
      _wheels.leftRearWheel.wheelColliderRPM = _wheels.leftRearWheel.wheelCollider.rpm;
      if (wheelTEIsGrounded) {
        sumRPM += _wheels.leftRearWheel.wheelColliderRPM;
      }
      for (int x = 0; x < _wheels.extraWheels.Length; x++) {
        _wheels.extraWheels[x].wheelColliderRPM = _wheels.extraWheels[x].wheelCollider.rpm;
        if (_wheels.extraWheels[x].wheelCollider.isGrounded) {
          sumRPM += _wheels.extraWheels[x].wheelColliderRPM;
        }
      }
      mediumRPM = sumRPM / groundedWheels;
      if (float.IsNaN(mediumRPM)) {
        mediumRPM = 0;
      }
      if (Mathf.Abs(mediumRPM) < 0.01f) {
        mediumRPM = 0.0f;
      }
    }
    void CheckGroundedWheelsOnFixedUpdate() {
      //get main wheels - is grounded
      wheelFDIsGrounded = _wheels.rightFrontWheel.wheelCollider.isGrounded;
      wheelFEIsGrounded = _wheels.leftFrontWheel.wheelCollider.isGrounded;
      wheelTDIsGrounded = _wheels.rightRearWheel.wheelCollider.isGrounded;
      wheelTEIsGrounded = _wheels.leftRearWheel.wheelCollider.isGrounded;
      //
      groundedWheels = 0;
      if (wheelFDIsGrounded) {
        groundedWheels++;
      }
      if (wheelFEIsGrounded) {
        groundedWheels++;
      }
      if (wheelTDIsGrounded) {
        groundedWheels++;
      }
      if (wheelTEIsGrounded) {
        groundedWheels++;
      }
      for (int x = 0; x < _wheels.extraWheels.Length; x++) {
        if (_wheels.extraWheels[x].wheelCollider.isGrounded) {
          groundedWheels++;
        }
      }
    }



    public void EnterInVehicle(bool _isPlayer) {
      if (_vehicleState == ControlState.isNull || _isPlayer) {
        if (_isPlayer) {
          _vehicleState = ControlState.isPlayer;
        } else {
          automaticGears = true;
          handBrakeTrue = false;
          handBrakeSoundWasPlayed = true;
        }
      }
    }

    public void ExitTheVehicle() {
      if (_vehicleState == ControlState.isPlayer) {
        _vehicleState = ControlState.isNull;
        if (automaticGears) {
          handBrakeTrue = true;
          handBrakeSoundWasPlayed = true;
        }
      }
    }

    public void SetWheelCollidersFrictionFixedUpdate(WheelCollider collider) {
      if (collider.isGrounded) {
        bool changeFriction = false;
        bool changeWheelsFriction = false;
        float nextFrictionFW = 99;
        float nextFrictionSW = 99;
        collider.GetGroundHit(out tempWheelHit);
        for (int x = 0; x < _groundFriction.grounds.Length; x++) {
          if (!changeWheelsFriction) {
            switch (_groundDetection) {
              case GroundDetectionMode.Tag:
                if (!string.IsNullOrEmpty(_groundFriction.grounds[x].groundTag)) {
                  if (tempWheelHit.collider.gameObject.CompareTag(_groundFriction.grounds[x].groundTag)) {
                    nextFrictionFW = _groundFriction.grounds[x].forwardFriction;
                    nextFrictionSW = _groundFriction.grounds[x].sidewaysFriction;
                    changeWheelsFriction = true;
                    break;
                  }
                }
                break;
              //==============================================================================================================================
              case GroundDetectionMode.PhysicMaterial:
                if (_groundFriction.grounds[x].physicMaterial) {
                  if (tempWheelHit.collider.sharedMaterial == _groundFriction.grounds[x].physicMaterial) {
                    nextFrictionFW = _groundFriction.grounds[x].forwardFriction;
                    nextFrictionSW = _groundFriction.grounds[x].sidewaysFriction;
                    changeWheelsFriction = true;
                    break;
                  }
                }
                break;
              //==============================================================================================================================
              case GroundDetectionMode.TerrainTextureIndices:
                if (activeTerrain_optional) {
                  if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                    int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                    if (dominantTerrainIndex != -1) {
                      if (_groundFriction.grounds[x].terrainTextureIndices.Count > 0 && _groundFriction.grounds[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                        nextFrictionFW = _groundFriction.grounds[x].forwardFriction;
                        nextFrictionSW = _groundFriction.grounds[x].sidewaysFriction;
                        changeWheelsFriction = true;
                        break;
                      }
                    }
                  }
                }
                break;
              //==============================================================================================================================
              case GroundDetectionMode.All:
                //tag
                if (!string.IsNullOrEmpty(_groundFriction.grounds[x].groundTag)) {
                  if (tempWheelHit.collider.gameObject.CompareTag(_groundFriction.grounds[x].groundTag)) {
                    nextFrictionFW = _groundFriction.grounds[x].forwardFriction;
                    nextFrictionSW = _groundFriction.grounds[x].sidewaysFriction;
                    changeWheelsFriction = true;
                    break;
                  }
                }
                //physicMaterial
                if (_groundFriction.grounds[x].physicMaterial) {
                  if (tempWheelHit.collider.sharedMaterial == _groundFriction.grounds[x].physicMaterial) {
                    nextFrictionFW = _groundFriction.grounds[x].forwardFriction;
                    nextFrictionSW = _groundFriction.grounds[x].sidewaysFriction;
                    changeWheelsFriction = true;
                    break;
                  }
                }
                //terrainTextureIndice
                if (activeTerrain_optional) {
                  if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                    int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                    if (dominantTerrainIndex != -1) {
                      if (_groundFriction.grounds[x].terrainTextureIndices.Count > 0 && _groundFriction.grounds[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                        nextFrictionFW = _groundFriction.grounds[x].forwardFriction;
                        nextFrictionSW = _groundFriction.grounds[x].sidewaysFriction;
                        changeWheelsFriction = true;
                        break;
                      }
                    }
                  }
                }
                break;
                //==============================================================================================================================
            }
          }
        }
        if (!changeWheelsFriction) {
          nextFrictionFW = _groundFriction.standardForwardFriction;
          nextFrictionSW = _groundFriction.standardSideFriction;
        }
        if ((collider.forwardFriction.stiffness != nextFrictionFW) || (collider.sidewaysFriction.stiffness != nextFrictionSW)) {
          changeFriction = true;
        }

        if (changeFriction) {
          WheelFrictionCurve wheelFrictionCurveFW = new WheelFrictionCurve();
          WheelFrictionCurve wheelFrictionCurveSW = new WheelFrictionCurve();
          wheelFrictionCurveFW.stiffness = nextFrictionFW;
          wheelFrictionCurveSW.stiffness = nextFrictionSW;
          //friction Fw
          wheelFrictionCurveFW.extremumSlip = collider.forwardFriction.extremumSlip;
          wheelFrictionCurveFW.extremumValue = collider.forwardFriction.extremumValue;
          wheelFrictionCurveFW.asymptoteSlip = collider.forwardFriction.asymptoteSlip;
          wheelFrictionCurveFW.asymptoteValue = collider.forwardFriction.asymptoteValue;
          collider.forwardFriction = wheelFrictionCurveFW;
          //friction Sw
          wheelFrictionCurveSW.extremumSlip = collider.sidewaysFriction.extremumSlip;
          wheelFrictionCurveSW.extremumValue = collider.sidewaysFriction.extremumValue;
          wheelFrictionCurveSW.asymptoteSlip = collider.sidewaysFriction.asymptoteSlip;
          wheelFrictionCurveSW.asymptoteValue = collider.sidewaysFriction.asymptoteValue;
          collider.sidewaysFriction = wheelFrictionCurveSW;
        }
      }
    }

    void SetWheelForces(WheelCollider wheelCollider) {
      wheelCollider.GetGroundHit(out tempWheelHit);
      if (wheelCollider.isGrounded) {
        TireSlips(wheelCollider, tempWheelHit);

        //lateral forces
        float distanceXForceTemp = ms_Rigidbody.centerOfMass.y - transform.InverseTransformPoint(wheelCollider.transform.position).y + wheelCollider.radius + (1.0f - wheelCollider.suspensionSpring.targetPosition) * wheelCollider.suspensionDistance;
        Vector3 lateralForcePointTemp = tempWheelHit.point + wheelCollider.transform.up * _vehiclePhysicStabilizers.helpToStraightenOut * distanceXForceTemp;
        Vector3 lateralForceTemp = tempWheelHit.sidewaysDir * (tireFO.x);
        if (Mathf.Abs(volantDir_horizontalInput) > 0.1f && wheelCollider.steerAngle != 0.0f && Mathf.Sign(wheelCollider.steerAngle) != Mathf.Sign(tireSL.x)) {
          lateralForcePointTemp += tempWheelHit.forwardDir * _vehiclePhysicStabilizers.helpToTurn;
        }
        ms_Rigidbody.AddForceAtPosition(lateralForceTemp, lateralForcePointTemp);

        //forword forces - only take effect if the vehicle exceeds the maximum speed
        Vector3 forwardForceTemp = tempWheelHit.forwardDir * (tireFO.y) * 3;
        ms_Rigidbody.AddForceAtPosition(forwardForceTemp, tempWheelHit.point + transform.up); //if (kmh > maxSpeed) = 1, else, = 0
      }
    }

    public Vector2 WheelLocalVelocity(WheelHit wheelHit) {
      Vector2 tempLocalVelocityVector2 = new Vector2(0, 0);
      Vector3 tempWheelVelocityVector3 = ms_Rigidbody.GetPointVelocity(wheelHit.point);
      Vector3 velocityLocalWheelTemp = tempWheelVelocityVector3 - Vector3.Project(tempWheelVelocityVector3, wheelHit.normal);
      tempLocalVelocityVector2.y = (float)Math.Round(Vector3.Dot(wheelHit.forwardDir, velocityLocalWheelTemp), 3);
      tempLocalVelocityVector2.x = (float)Math.Round(Vector3.Dot(wheelHit.sidewaysDir, velocityLocalWheelTemp), 3);
      return tempLocalVelocityVector2;
    }
    public Vector2 LocalSurfaceForce(WheelHit wheelHit) {
      //get Ribidbody velocity point
      Vector3 rbPointVel = ms_Rigidbody.GetPointVelocity(wheelHit.point);
      Vector3 wheelSpeedLocalSurface = new Vector3((float)Math.Round(rbPointVel.x, 3), (float)Math.Round(rbPointVel.y, 3), (float)Math.Round(rbPointVel.z, 3));
      //
      //(if < 1.0), return 1    //   (if > 10.0f), return 0         /default = 1.0, 0.25
      float forceFactorTempLocalSurface = Mathf.InverseLerp(10.0f, 1.0f, (wheelSpeedLocalSurface - Vector3.Project(wheelSpeedLocalSurface, wheelHit.normal)).sqrMagnitude);
      //
      Vector2 surfaceLocalForce = Vector2.zero;
      if (forceFactorTempLocalSurface > 0.0f) {
        Vector3 surfaceLocalForceTemp = Vector3.up * 1000000.0f;
        float normalTemp = Vector3.Dot(Vector3.up, wheelHit.normal);
        if (normalTemp > 0.000001f) {
          Vector3 downForceUPTemp = Vector3.up * wheelHit.force / normalTemp;
          surfaceLocalForceTemp = downForceUPTemp - Vector3.Project(downForceUPTemp, wheelHit.normal);
        }
        surfaceLocalForce.y = (float)Math.Round(Vector3.Dot(wheelHit.forwardDir, surfaceLocalForceTemp), 3);
        surfaceLocalForce.x = (float)Math.Round(Vector3.Dot(wheelHit.sidewaysDir, surfaceLocalForceTemp), 3);
        surfaceLocalForce *= forceFactorTempLocalSurface;
      }
      return surfaceLocalForce;
    }

    public void TireSlips(WheelCollider wheelCollider, WheelHit wheelHit) {
      Vector2 tireSlips = Vector2.zero;
      Vector2 tireForces = Vector2.zero;
      float minSlipY = 0;
      Vector2 localVelocityWheelTireSlips = WheelLocalVelocity(wheelHit);
      Vector2 localSurfaceForceDTireSlips = LocalSurfaceForce(wheelHit); //if (wheel relative velocity < 0.25), this force is 1, else, this force is 0

      float reverseForce = 0;
      if (KMh > _vehicleTorque.maxVelocityKMh) {
        reverseForce = -(ms_Rigidbody.velocity.magnitude * _vehicleSettings.vehicleMass * 0.003f);
      }

      tireSlips.x = localVelocityWheelTireSlips.x;
      tireSlips.y = (tempWheelHit.sidewaysSlip * (Mathf.Abs(verticalInput) + Mathf.Abs(volantDir_horizontalInput)));
      float downForceTireSlips = _vehiclePhysicStabilizers.localSurfaceForce * _vehicleSettings.vehicleMass * (wheelCollider.suspensionSpring.spring * 0.000025f);
      if (wheelCollider.brakeTorque > 10) {
        float wheelMaxBrakeSlip = Mathf.Max(Mathf.Abs(localVelocityWheelTireSlips.y * 0.2f), 0.3f);
        minSlipY = Mathf.Clamp(Mathf.Abs(reverseForce * tireSlips.x) / downForceTireSlips, 0.0f, wheelMaxBrakeSlip);
      } else {
        minSlipY = Mathf.Min(Mathf.Abs(reverseForce * tireSlips.x) / downForceTireSlips, Mathf.Clamp((verticalInput * 2.5f), -2.5f, 1.0f));
        if (reverseForce != 0.0f && minSlipY < 0.1f) {
          minSlipY = 0.1f;
        }
      }

      if (Mathf.Abs(tireSlips.y) < minSlipY) {
        tireSlips.y = minSlipY * Mathf.Sign(tireSlips.y);
      }
      Vector2 rawTireForceTireSlips = -(downForceTireSlips * tireSlips.normalized);
      rawTireForceTireSlips.x = Mathf.Abs(rawTireForceTireSlips.x);
      rawTireForceTireSlips.y = Mathf.Abs(rawTireForceTireSlips.y);

      float estimatedSprungMass = Mathf.Clamp(wheelHit.force / Mathf.Abs(Physics.gravity.y), 0.0f, wheelCollider.sprungMass) * 0.5f;
      Vector2 localRigForceTireSlips = (-estimatedSprungMass * localVelocityWheelTireSlips * (1 / fixedDeltaTime)) + localSurfaceForceDTireSlips * _vehiclePhysicStabilizers.localSurfaceForce;
      tireForces.x = Mathf.Clamp(localRigForceTireSlips.x, -rawTireForceTireSlips.x * _vehiclePhysicStabilizers.localSurfaceForce, +rawTireForceTireSlips.x * _vehiclePhysicStabilizers.localSurfaceForce);
      tireForces.y = Mathf.Clamp(reverseForce, -rawTireForceTireSlips.y, +rawTireForceTireSlips.y);//only active if kmh > maxSpeed

      tireSL = tireSlips * _vehiclePhysicStabilizers.tireSlipsFactor;
      tireFO = tireForces * _vehiclePhysicStabilizers.tireSlipsFactor;
    }



    void UpdateWheelMeshes() {

      //rightFrontWheel
      _wheels.rightFrontWheel.wheelCollider.GetWorldPose(out Vector3 posWheel, out Quaternion rotWheel);
      _wheels.rightFrontWheel.wheelWorldPosition = posWheel;
      if (_wheels.rightFrontWheel.wheelMesh) {
        _wheels.rightFrontWheel.wheelMesh.SetPositionAndRotation(posWheel, rotWheel);
      }
      //leftFrontWheel
      _wheels.leftFrontWheel.wheelCollider.GetWorldPose(out posWheel, out rotWheel);
      _wheels.leftFrontWheel.wheelWorldPosition = posWheel;
      if (_wheels.leftFrontWheel.wheelMesh) {
        _wheels.leftFrontWheel.wheelMesh.SetPositionAndRotation(posWheel, rotWheel);
      }
      //rightRearWheel
      _wheels.rightRearWheel.wheelCollider.GetWorldPose(out posWheel, out rotWheel);
      _wheels.rightRearWheel.wheelWorldPosition = posWheel;
      if (_wheels.rightRearWheel.wheelMesh) {
        _wheels.rightRearWheel.wheelMesh.SetPositionAndRotation(posWheel, rotWheel);
      }
      //leftRearWheel
      _wheels.leftRearWheel.wheelCollider.GetWorldPose(out posWheel, out rotWheel);
      _wheels.leftRearWheel.wheelWorldPosition = posWheel;
      if (_wheels.leftRearWheel.wheelMesh) {
        _wheels.leftRearWheel.wheelMesh.SetPositionAndRotation(posWheel, rotWheel);
      }

      if (_wheels.extraWheels.Length > 0) {
        for (int i = 0; i < _wheels.extraWheels.Length; i++) {
          if (_wheels.extraWheels[i].wheelCollider) {
            _wheels.extraWheels[i].wheelCollider.GetWorldPose(out posWheel, out rotWheel);
            _wheels.extraWheels[i].wheelWorldPosition = posWheel;
            if (_wheels.extraWheels[i].wheelMesh) {
              _wheels.extraWheels[i].wheelMesh.SetPositionAndRotation(posWheel, rotWheel);
            }
          }
        }
      }
    }

    void StabilizeAngularRotation() {
      if (_vehiclePhysicStabilizers.stabilizeAngularVelocity > 0.1f) {  // Avoid unnecessary processing for very low forces
        if (Mathf.Abs(volantDir_horizontalInput) < 0.9f) {
          ms_Rigidbody.angularVelocity = Vector3.Lerp(ms_Rigidbody.angularVelocity, new Vector3(ms_Rigidbody.angularVelocity.x, 0, ms_Rigidbody.angularVelocity.z), fixedDeltaTime * _vehiclePhysicStabilizers.stabilizeAngularVelocity);
        }
      }
    }

    void StabilizeAirRotation() {
      if (_vehicleState == ControlState.isPlayer) {
        if (_vehiclePhysicStabilizers.airRotation > 0.02f) {  // Avoid unnecessary processing for very low forces
          if (!colliding) {
            if (groundedWheels == 0) {
              Vector3 axisFromRotate = Vector3.Cross(transform.up, Vector3.up);
              Vector3 torqueForceAirRotation = _vehiclePhysicStabilizers.airRotation * 5.0f * axisFromRotate.magnitude * axisFromRotate.normalized;
              torqueForceAirRotation -= ms_Rigidbody.angularVelocity;
              ms_Rigidbody.AddTorque(_vehicleSettings.vehicleMass * 0.02f * torqueForceAirRotation, ForceMode.Impulse);
              if (Mathf.Abs(volantDir_horizontalInput) > 0.1f) {
                ms_Rigidbody.AddTorque(_vehiclePhysicStabilizers.airRotation * _vehicleSettings.vehicleMass * 1.5f * -volantDir_horizontalInput * transform.forward);
              }
              if (Mathf.Abs(verticalInput) > 0.1f) {
                ms_Rigidbody.AddTorque(_vehiclePhysicStabilizers.airRotation * _vehicleSettings.vehicleMass * 1.1f * verticalInput * transform.right);
              }
            }
          }
        }
      }
    }

    void StabilizeMotorBrakeForce() {
      if (theEngineIsRunning) {
        int currentGearApplyForce = 0;
        if (currentGear > 0) {
          currentGearApplyForce = (currentGear - 1);
        }
        //
        int forwardForce = 1;
        if (KMh > (_vehicleTorque.maxVelocityGears[currentGearApplyForce] * _vehicleTorque.speedOfGear * _brakes.speedFactorEngineBrake)) {
          if (wheelFDIsGrounded && wheelFEIsGrounded && wheelTDIsGrounded && wheelTEIsGrounded) {
            if (currentGear > 0 && mediumRPM > 0) {
              forwardForce = 1;
            } else if (currentGear <= 0 && mediumRPM < 0) {
              forwardForce = -1;
            } else {
              forwardForce = 0;
            }
            float finalForce = _brakes.forceEngineBrake * _vehicleSettings.vehicleMass * forwardForce * 5;
            if (Mathf.Abs(KMh) > 1.2f) {
              currentEngineBrakeLerpValue = Mathf.Lerp(currentEngineBrakeLerpValue, finalForce, fixedDeltaTime);
              ms_Rigidbody.AddForce(-transform.forward * currentEngineBrakeLerpValue);
            } else {
              currentEngineBrakeLerpValue = Mathf.Lerp(currentEngineBrakeLerpValue, 0.0f, fixedDeltaTime);
            }
          }
        } else {
          currentEngineBrakeLerpValue = Mathf.Lerp(currentEngineBrakeLerpValue, 0.0f, fixedDeltaTime);
        }
      } else {
        currentEngineBrakeLerpValue = 0;
      }
    }

    void StabilizeVehicleRotation() {
      if (_vehiclePhysicStabilizers.stabilizeSlippage > 0.1f) {
        _wheels.rightFrontWheel.wheelCollider.GetGroundHit(out tempWheelHit);
        if (tempWheelHit.normal == Vector3.zero) {
          return;
        }
        _wheels.leftFrontWheel.wheelCollider.GetGroundHit(out tempWheelHit);
        if (tempWheelHit.normal == Vector3.zero) {
          return;
        }
        _wheels.rightRearWheel.wheelCollider.GetGroundHit(out tempWheelHit);
        if (tempWheelHit.normal == Vector3.zero) {
          return;
        }
        _wheels.leftRearWheel.wheelCollider.GetGroundHit(out tempWheelHit);
        if (tempWheelHit.normal == Vector3.zero) {
          return;
        }
        for (int x = 0; x < _wheels.extraWheels.Length; x++) {
          _wheels.extraWheels[x].wheelCollider.GetGroundHit(out tempWheelHit);
          if (tempWheelHit.normal == Vector3.zero) {
            return;
          }
        }

        if (Mathf.Abs(previousRotation - transform.eulerAngles.y) < 10f) {
          var tempQuaternion = (transform.eulerAngles.y - previousRotation) * _vehiclePhysicStabilizers.stabilizeSlippage;
          Quaternion tempRotStabilizers = Quaternion.AngleAxis(tempQuaternion, Vector3.up);
          ms_Rigidbody.velocity = tempRotStabilizers * ms_Rigidbody.velocity;
        }

        previousRotation = transform.eulerAngles.y;
      }
    }

    void StabilizeVehicleRollForces() {
      if (_vehiclePhysicStabilizers.antiRollForce > 0.05f) { // Avoid unnecessary processing for very low forces
        float leftFrontForce = 1.0f;
        float rightFrontForce = 1.0f;
        float leftRearForce = 1.0f;
        float rightRearForce = 1.0f;

        // [-_wheels.leftRearWheel.wheelCollider.transform.InverseTransformPoint (tempWheelHit.point).y] >> Is the distance between the center of the wheel and the hit.point

        //Rear wheels 
        bool isGround1 = _wheels.leftRearWheel.wheelCollider.GetGroundHit(out tempWheelHit);
        if (isGround1) {
          leftRearForce = (-_wheels.leftRearWheel.wheelCollider.transform.InverseTransformPoint(tempWheelHit.point).y - _wheels.leftRearWheel.wheelCollider.radius) / _wheels.leftRearWheel.wheelCollider.suspensionDistance;
        }
        bool isGround2 = _wheels.rightRearWheel.wheelCollider.GetGroundHit(out tempWheelHit);
        if (isGround2) {
          rightRearForce = (-_wheels.rightRearWheel.wheelCollider.transform.InverseTransformPoint(tempWheelHit.point).y - _wheels.rightRearWheel.wheelCollider.radius) / _wheels.rightRearWheel.wheelCollider.suspensionDistance;
        }
        //front wheels
        bool isGround3 = _wheels.leftFrontWheel.wheelCollider.GetGroundHit(out tempWheelHit);
        if (isGround3) {
          leftFrontForce = (-_wheels.leftFrontWheel.wheelCollider.transform.InverseTransformPoint(tempWheelHit.point).y - _wheels.leftFrontWheel.wheelCollider.radius) / _wheels.leftFrontWheel.wheelCollider.suspensionDistance;
        }
        bool isGround4 = _wheels.rightFrontWheel.wheelCollider.GetGroundHit(out tempWheelHit);
        if (isGround4) {
          rightFrontForce = (-_wheels.rightFrontWheel.wheelCollider.transform.InverseTransformPoint(tempWheelHit.point).y - _wheels.rightFrontWheel.wheelCollider.radius) / _wheels.rightFrontWheel.wheelCollider.suspensionDistance;
        }

        //apply forces 
        float roolForce1 = (leftRearForce - rightRearForce) * _vehiclePhysicStabilizers.antiRollForce * _vehicleSettings.vehicleMass * inclinationFactorForcesDown;
        float roolForce2 = (leftFrontForce - rightFrontForce) * _vehiclePhysicStabilizers.antiRollForce * _vehicleSettings.vehicleMass * inclinationFactorForcesDown;
        //rear wheels
        if (isGround1) {
          ms_Rigidbody.AddForceAtPosition(_wheels.leftRearWheel.wheelCollider.transform.up * -roolForce1, _wheels.leftRearWheel.wheelCollider.transform.position);
        }
        if (isGround2) {
          ms_Rigidbody.AddForceAtPosition(_wheels.rightRearWheel.wheelCollider.transform.up * roolForce1, _wheels.rightRearWheel.wheelCollider.transform.position);
        }
        //front wheels
        if (isGround3) {
          ms_Rigidbody.AddForceAtPosition(_wheels.leftFrontWheel.wheelCollider.transform.up * -roolForce2, _wheels.leftFrontWheel.wheelCollider.transform.position);
        }
        if (isGround4) {
          ms_Rigidbody.AddForceAtPosition(_wheels.rightFrontWheel.wheelCollider.transform.up * roolForce2, _wheels.rightFrontWheel.wheelCollider.transform.position);
        }
      }
    }



    void FuelManager() {
      if (theEngineIsRunning) {
        if (!_fuel.infinityFuel) {
          currentFuelLiters -= (((Mathf.Clamp(pitchAUDforRPM, 0.85f, _sounds.speedOfEngineSound) / _sounds.speedOfEngineSound) * Time.deltaTime) / 10.0f) * _fuel.consumption;
        } else {
          currentFuelLiters = _fuel.capacityInLiters;
        }

        if (currentFuelLiters <= 0) {
          currentFuelLiters = 0;
          StartCoroutine(nameof(StartEngineCoroutine), false);
        }
      }
    }



    void ParticlesEmitter() {
      if (enableParticlesOnStart) {
        //nitro
        if (_additionalFeatures.useNitro) {
          if (_particles.nitroParticles.Length > 0) {
            for (int x = 0; x < _particles.nitroParticles.Length; x++) {
              ParticleSystem.EmissionModule tempParticleN = _particles.nitroParticles[x].emission;
              if (_additionalFeatures.nitroIsTrueVar) {
                if (!_particles.nitroParticles[x].isPlaying) {
                  _particles.nitroParticles[x].Play(true);
                }
                tempParticleN.enabled = true;
              } else {
                tempParticleN.enabled = false;
              }
            }
          }
        }

        //exhaustSmoke
        if (_particles.exhaustSmoke.Length > 0) {
          if (theEngineIsRunning) {
            for (int x = 0; x < _particles.exhaustSmoke.Length; x++) {
              if (_particles.exhaustSmoke[x].smoke) {
                ParticleSystem.EmissionModule particleTemp = _particles.exhaustSmoke[x].smoke.emission;
                ParticleSystem.MainModule mainModule = _particles.exhaustSmoke[x].smoke.main;
                if (KMh < _particles.exhaustSmoke[x].criticalVelocity) {
                  particleTemp.enabled = true;
                  if (Mathf.Abs(verticalInput) > 0.05f) {
                    mainModule.startSpeed = 2.5f + 0.1f * KMh;
                  } else {
                    mainModule.startSpeed = 1.5f;
                  }
                } else {
                  particleTemp.enabled = false;
                }
              }
            }
          } else {
            for (int x = 0; x < _particles.exhaustSmoke.Length; x++) {
              if (_particles.exhaustSmoke[x].smoke) {
                ParticleSystem.EmissionModule particleTemp = _particles.exhaustSmoke[x].smoke.emission;
                particleTemp.enabled = false;
              }
            }
          }
        }
      }
      //dust generated by wheels
      if (wheelDustParticle) {
        if (_groundParticles.Length > 0) {
          for (int x = 0; x < _groundParticles.Length; x++) { //ground for
            for (int y = 0; y < _groundParticles[x].wheelDustList.Count; y++) {//particles for

              //get groundHit
              bool itsColliding = wheelColliderList[y].GetGroundHit(out tempWheelHit);
              //get particle
              ParticleSystem.EmissionModule particleTemp = _groundParticles[x].wheelDustList[y].emission;
              //set particle position
              if (wheelColliderList[y].isGrounded) {
                _groundParticles[x].wheelDustList[y].transform.position = tempWheelHit.point;
              }

              if (itsColliding && KMh > _groundParticles[x].criticalVelocity) {
                switch (_groundDetection) {
                  case GroundDetectionMode.Tag:
                    if (!string.IsNullOrEmpty(_groundParticles[x].groundTag)) {
                      if (tempWheelHit.collider.gameObject.CompareTag(_groundParticles[x].groundTag)) {
                        particleTemp.enabled = true;
                      } else {
                        particleTemp.enabled = false;
                      }
                    } else {
                      particleTemp.enabled = false;
                    }
                    break;
                  //==============================================================================================================================
                  case GroundDetectionMode.PhysicMaterial:
                    if (_groundParticles[x].physicMaterial) {
                      if (tempWheelHit.collider.sharedMaterial == _groundParticles[x].physicMaterial) {
                        particleTemp.enabled = true;
                      } else {
                        particleTemp.enabled = false;
                      }
                    } else {
                      particleTemp.enabled = false;
                    }
                    break;
                  //==============================================================================================================================
                  case GroundDetectionMode.TerrainTextureIndices:
                    if (activeTerrain_optional) {
                      if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                        int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                        if (dominantTerrainIndex != -1) {
                          if (_groundParticles[x].terrainTextureIndices.Count > 0 && _groundParticles[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                            particleTemp.enabled = true;
                          } else {
                            particleTemp.enabled = false;
                          }
                        } else {
                          particleTemp.enabled = false;
                        }
                      } else {
                        particleTemp.enabled = false;
                      }
                    } else {
                      particleTemp.enabled = false;
                    }
                    break;
                  //==============================================================================================================================
                  case GroundDetectionMode.All:
                    //tag
                    if (!string.IsNullOrEmpty(_groundParticles[x].groundTag)) {
                      if (tempWheelHit.collider.gameObject.CompareTag(_groundParticles[x].groundTag)) {
                        particleTemp.enabled = true;
                        break;
                      } else {
                        particleTemp.enabled = false;
                      }
                    } else {
                      particleTemp.enabled = false;
                    }
                    //physicMaterial
                    if (_groundParticles[x].physicMaterial) {
                      if (tempWheelHit.collider.sharedMaterial == _groundParticles[x].physicMaterial) {
                        particleTemp.enabled = true;
                        break;
                      } else {
                        particleTemp.enabled = false;
                      }
                    } else {
                      particleTemp.enabled = false;
                    }
                    //terrainTextureIndice
                    if (activeTerrain_optional) {
                      if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                        int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                        if (dominantTerrainIndex != -1) {
                          if (_groundParticles[x].terrainTextureIndices.Count > 0 && _groundParticles[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                            particleTemp.enabled = true;
                            break;
                          } else {
                            particleTemp.enabled = false;
                          }
                        } else {
                          particleTemp.enabled = false;
                        }
                      } else {
                        particleTemp.enabled = false;
                      }
                    } else {
                      particleTemp.enabled = false;
                    }
                    break;
                    //==============================================================================================================================
                }
              } else {
                particleTemp.enabled = false;
              }
            }
          }
        }
      }
    }



    public AudioSource GenerateAudioSource(string name, float minDistance, float volume, AudioClip audioClip, bool loop, bool playNow, bool playAwake, GameObject gameObjectParent, float minDist3D, float maxDist3D) {
      GameObject audioSource = new GameObject(name);
      audioSource.transform.position = transform.position;
      audioSource.transform.parent = gameObjectParent.transform;
      AudioSource temp = audioSource.AddComponent<AudioSource>() as AudioSource;
      temp.minDistance = minDistance;
      temp.volume = volume;
      temp.clip = audioClip;
      temp.loop = loop;
      temp.playOnAwake = playAwake;
      temp.spatialBlend = 1.0f;
      temp.dopplerLevel = 0.0f;
      temp.rolloffMode = AudioRolloffMode.Logarithmic;
      temp.minDistance = minDist3D;
      temp.maxDistance = maxDist3D;
      if (playNow) {
        temp.Play();
      }
      return temp;
    }

    void GroundSoundsEmitter(WheelCollider[] wheelColliders) {
      for (int j = 0; j < _groundSounds.groundSounds.Length; j++) {
        wheelEmitterSoundX[j] = 0;
        wheelBlockSoundX[j] = 0;
      }
      for (int i = 0; i < wheelColliders.Length; i++) {
        wheelColliders[i].GetGroundHit(out tempWheelHit);
        for (int x = 0; x < _groundSounds.groundSounds.Length; x++) {
          if (_groundSounds.groundSounds[x].groundSound) {
            if (wheelColliders[i].isGrounded) {
              switch (_groundDetection) {
                case GroundDetectionMode.Tag:
                  if (!string.IsNullOrEmpty(_groundSounds.groundSounds[x].groundTag)) {
                    if (tempWheelHit.collider.gameObject.CompareTag(_groundSounds.groundSounds[x].groundTag)) {
                      wheelEmitterSoundX[x]++;
                      if (!groundSoundsAUD[x].isPlaying && groundSoundsAUD[x]) {
                        groundSoundsAUD[x].PlayOneShot(groundSoundsAUD[x].clip);
                      }
                    } else {
                      wheelBlockSoundX[x]++;
                    }
                  } else {
                    wheelBlockSoundX[x]++;
                  }
                  break;
                //==============================================================================================================================
                case GroundDetectionMode.PhysicMaterial:
                  if (_groundSounds.groundSounds[x].physicMaterial) {
                    if (tempWheelHit.collider.sharedMaterial == _groundSounds.groundSounds[x].physicMaterial) {
                      wheelEmitterSoundX[x]++;
                      if (!groundSoundsAUD[x].isPlaying && groundSoundsAUD[x]) {
                        groundSoundsAUD[x].PlayOneShot(groundSoundsAUD[x].clip);
                      }
                    } else {
                      wheelBlockSoundX[x]++;
                    }
                  } else {
                    wheelBlockSoundX[x]++;
                  }
                  break;
                //==============================================================================================================================
                case GroundDetectionMode.TerrainTextureIndices:
                  if (activeTerrain_optional) {
                    if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                      int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                      if (dominantTerrainIndex != -1) {
                        if (_groundSounds.groundSounds[x].terrainTextureIndices.Count > 0 && _groundSounds.groundSounds[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                          wheelEmitterSoundX[x]++;
                          if (!groundSoundsAUD[x].isPlaying && groundSoundsAUD[x]) {
                            groundSoundsAUD[x].PlayOneShot(groundSoundsAUD[x].clip);
                          }
                        } else {
                          wheelBlockSoundX[x]++;
                        }
                      } else {
                        wheelBlockSoundX[x]++;
                      }
                    } else {
                      wheelBlockSoundX[x]++;
                    }
                  } else {
                    wheelBlockSoundX[x]++;
                  }
                  break;
                //==============================================================================================================================
                case GroundDetectionMode.All:
                  bool emitterSoundXBool = false;
                  //tag
                  if (!string.IsNullOrEmpty(_groundSounds.groundSounds[x].groundTag)) {
                    if (tempWheelHit.collider.gameObject.CompareTag(_groundSounds.groundSounds[x].groundTag)) {
                      emitterSoundXBool = true;
                      if (!groundSoundsAUD[x].isPlaying && groundSoundsAUD[x]) {
                        groundSoundsAUD[x].PlayOneShot(groundSoundsAUD[x].clip);
                      }
                    }
                  }
                  //physicMaterial
                  if (!emitterSoundXBool) {
                    if (_groundSounds.groundSounds[x].physicMaterial) {
                      if (tempWheelHit.collider.sharedMaterial == _groundSounds.groundSounds[x].physicMaterial) {
                        emitterSoundXBool = true;
                        if (!groundSoundsAUD[x].isPlaying && groundSoundsAUD[x]) {
                          groundSoundsAUD[x].PlayOneShot(groundSoundsAUD[x].clip);
                        }
                      }
                    }
                  }
                  //terrainTextureIndice
                  if (!emitterSoundXBool) {
                    if (activeTerrain_optional) {
                      if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                        int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                        if (dominantTerrainIndex != -1) {
                          if (_groundSounds.groundSounds[x].terrainTextureIndices.Count > 0 && _groundSounds.groundSounds[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                            emitterSoundXBool = true;
                            if (!groundSoundsAUD[x].isPlaying && groundSoundsAUD[x]) {
                              groundSoundsAUD[x].PlayOneShot(groundSoundsAUD[x].clip);
                            }
                          }
                        }
                      }
                    }
                  }
                  //check
                  if (emitterSoundXBool) {
                    wheelEmitterSoundX[x]++;
                  } else {
                    wheelBlockSoundX[x]++;
                  }
                  break;
                  //==============================================================================================================================
              }
            } else {
              wheelBlockSoundX[x]++;
            }
          }
        }
      }
      for (int x = 0; x < _groundSounds.groundSounds.Length; x++) {
        if (wheelBlockSoundX[x] > 0 && wheelEmitterSoundX[x] == 0 && groundSoundsAUD[x]) {
          groundSoundsAUD[x].Stop();
        }
        if (ms_Rigidbody.velocity.magnitude < 2.0f && groundSoundsAUD[x]) {
          groundSoundsAUD[x].Stop();
        }
      }
    }

    void CheckSKidForward(float wheelRPM, float sens1, float forwardSKid, float sens3) {
      if (KMh > sens1) {
        if (wheelRPM < (0.3333333 * _skidMarks.sensibility)) {
          forwardTempSKid = true;
        }
      }
      if (KMh < sens3) {
        if (forwardSKid > (0.8333333 * _skidMarks.sensibility)) {
          forwardTempSKid = true;
          forwardHandBrakeSKid = true;
        }
      }
      float RPMCondition = (1.75f / averageWheelRadius);// = 5.0f
      if (Mathf.Abs(wheelRPM) < RPMCondition && KMh > 5) {
        forwardTempSKid = true;
        forwardHandBrakeSKid = true;
      }
    }
    void SkiddingSounds() {
      forwardTempSKid = false;
      forwardHandBrakeSKid = false;
      float sidewaysSlipMaxSkid = 0;
      float forwardSlipMaxSkid = 0;
      float sensibility75kmh = (75.0f / _skidMarks.sensibility);
      float sensibilityLowSpeed = 20.0f * (Mathf.Clamp(_skidMarks.sensibility, 1, 3));
      //
      if (wheelFDIsGrounded) {
        _wheels.rightFrontWheel.wheelCollider.GetGroundHit(out tempWheelHit);
        _wheels.rightFrontWheel.sidewaysSkid = Mathf.Abs(tempWheelHit.sidewaysSlip);
        if (_wheels.rightFrontWheel.sidewaysSkid > sidewaysSlipMaxSkid) {
          sidewaysSlipMaxSkid = _wheels.rightFrontWheel.sidewaysSkid;
        }
        _wheels.rightFrontWheel.forwardSkid = Mathf.Abs(tempWheelHit.forwardSlip * _skidMarks.forwordSensibility);
        if (_wheels.rightFrontWheel.forwardSkid > forwardSlipMaxSkid) {
          forwardSlipMaxSkid = _wheels.rightFrontWheel.forwardSkid;
        }
        CheckSKidForward(_wheels.rightFrontWheel.wheelColliderRPM, sensibility75kmh, _wheels.rightFrontWheel.forwardSkid, sensibilityLowSpeed);
      }
      //
      if (wheelFEIsGrounded) {
        _wheels.leftFrontWheel.wheelCollider.GetGroundHit(out tempWheelHit);
        _wheels.leftFrontWheel.sidewaysSkid = Mathf.Abs(tempWheelHit.sidewaysSlip);
        if (_wheels.leftFrontWheel.sidewaysSkid > sidewaysSlipMaxSkid) {
          sidewaysSlipMaxSkid = _wheels.leftFrontWheel.sidewaysSkid;
        }
        _wheels.leftFrontWheel.forwardSkid = Mathf.Abs(tempWheelHit.forwardSlip * _skidMarks.forwordSensibility);
        if (_wheels.leftFrontWheel.forwardSkid > forwardSlipMaxSkid) {
          forwardSlipMaxSkid = _wheels.leftFrontWheel.forwardSkid;
        }
        CheckSKidForward(_wheels.leftFrontWheel.wheelColliderRPM, sensibility75kmh, _wheels.leftFrontWheel.forwardSkid, sensibilityLowSpeed);
      }
      //
      if (wheelTDIsGrounded) {
        _wheels.rightRearWheel.wheelCollider.GetGroundHit(out tempWheelHit);
        _wheels.rightRearWheel.sidewaysSkid = Mathf.Abs(tempWheelHit.sidewaysSlip);
        if (_wheels.rightRearWheel.sidewaysSkid > sidewaysSlipMaxSkid) {
          sidewaysSlipMaxSkid = _wheels.rightRearWheel.sidewaysSkid;
        }
        _wheels.rightRearWheel.forwardSkid = Mathf.Abs(tempWheelHit.forwardSlip * _skidMarks.forwordSensibility);
        if (_wheels.rightRearWheel.forwardSkid > forwardSlipMaxSkid) {
          forwardSlipMaxSkid = _wheels.rightRearWheel.forwardSkid;
        }
        CheckSKidForward(_wheels.rightRearWheel.wheelColliderRPM, sensibility75kmh, _wheels.rightRearWheel.forwardSkid, sensibilityLowSpeed);
      }
      //
      if (wheelTEIsGrounded) {
        _wheels.leftRearWheel.wheelCollider.GetGroundHit(out tempWheelHit);
        _wheels.leftRearWheel.sidewaysSkid = Mathf.Abs(tempWheelHit.sidewaysSlip);
        if (_wheels.leftRearWheel.sidewaysSkid > sidewaysSlipMaxSkid) {
          sidewaysSlipMaxSkid = _wheels.leftRearWheel.sidewaysSkid;
        }
        _wheels.leftRearWheel.forwardSkid = Mathf.Abs(tempWheelHit.forwardSlip * _skidMarks.forwordSensibility);
        if (_wheels.leftRearWheel.forwardSkid > forwardSlipMaxSkid) {
          forwardSlipMaxSkid = _wheels.leftRearWheel.forwardSkid;
        }
        CheckSKidForward(_wheels.leftRearWheel.wheelColliderRPM, sensibility75kmh, _wheels.leftRearWheel.forwardSkid, sensibilityLowSpeed);
      }
      //
      for (int x = 0; x < _wheels.extraWheels.Length; x++) {
        if (_wheels.extraWheels[x].wheelCollider.isGrounded) {
          _wheels.extraWheels[x].wheelCollider.GetGroundHit(out tempWheelHit);
          _wheels.extraWheels[x].sidewaysSkid = Mathf.Abs(tempWheelHit.sidewaysSlip);
          if (_wheels.extraWheels[x].sidewaysSkid > sidewaysSlipMaxSkid) {
            sidewaysSlipMaxSkid = _wheels.extraWheels[x].sidewaysSkid;
          }
          _wheels.extraWheels[x].forwardSkid = Mathf.Abs(tempWheelHit.forwardSlip * _skidMarks.forwordSensibility);
          if (_wheels.extraWheels[x].forwardSkid > forwardSlipMaxSkid) {
            forwardSlipMaxSkid = _wheels.extraWheels[x].forwardSkid;
          }
          CheckSKidForward(_wheels.extraWheels[x].wheelColliderRPM, sensibility75kmh, _wheels.extraWheels[x].forwardSkid, sensibilityLowSpeed);
        }
      }
      //
      bool skiddingIsTrue = false;
      float maxSlipTemp = 0;
      if (sidewaysSlipMaxSkid > forwardSlipMaxSkid) {
        maxSlipTemp = sidewaysSlipMaxSkid;
      } else {
        maxSlipTemp = forwardSlipMaxSkid;
      }
      //
      if (forwardTempSKid || (maxSlipTemp > (1 / _skidMarks.sensibility))) {
        skiddingIsTrue = true;
      }
      if (forwardHandBrakeSKid) {
        maxSlipTemp = 0.8f;
      }

      //CHECK TAGS
      bool tempOtherGround = GroundSoundsEmitterSkid(wheelColliderList, maxSlipTemp, skiddingIsTrue);
      if (skiddingIsTrue) {
        if (!tempOtherGround) {//quer dizer que esta derrapando mas nao encontrou nenhuma (Tag, PhysicMaterial ou Terrain)
          skiddingSoundAUD.volume = Mathf.Lerp(skiddingSoundAUD.volume, (maxSlipTemp * _groundSounds.standardSkidVolume), Time.deltaTime * 7.0f);
          if (forwardTempSKid) {
            if (skiddingSoundAUD.volume < (0.3f * _groundSounds.standardSkidVolume)) {
              skiddingSoundAUD.volume = Mathf.Lerp(skiddingSoundAUD.volume, (0.3f * _groundSounds.standardSkidVolume), Time.deltaTime * 7.0f);
            }
          }
          if (!skiddingSoundAUD.isPlaying) {
            skiddingSoundAUD.Play();
          }
        } else {
          skiddingSoundAUD.volume = Mathf.Lerp(skiddingSoundAUD.volume, 0, Time.deltaTime * 7.0f);
          if (skiddingSoundAUD.volume < 0.3f) {
            skiddingSoundAUD.Stop();
          }
        }
      } else {
        skiddingSoundAUD.volume = Mathf.Lerp(skiddingSoundAUD.volume, 0, Time.deltaTime * 7.0f);
        if (skiddingSoundAUD.volume < 0.3f) {
          skiddingSoundAUD.Stop();
        }
      }
      //

      //This prevents the vehicle from emitting skidding sounds if no wheel is touching the ground.
      if (groundedWheels == 0) {
        //default skid sound
        skiddingSoundAUD.volume = 0;
        skiddingSoundAUD.Stop();
        //other grounds skid sounds
        for (int x = 0; x < _groundSounds.groundSounds.Length; x++) {
          groundSoundsAUDSkid[x].volume = 0;
          groundSoundsAUDSkid[x].Stop();
        }
      }
    }
    bool GroundSoundsEmitterSkid(WheelCollider[] wheelColliders, float slipForVolume, bool skidIsTrue) {
      for (int j = 0; j < _groundSounds.groundSounds.Length; j++) {
        wheelEmitterSoundXSkid[j] = 0;
        wheelBlockSoundXSkid[j] = 0;
      }
      bool otherGround = false;
      int wheelsInOtherGround = 0;
      int maxWheels = 0;
      for (int i = 0; i < wheelColliders.Length; i++) {//WHEELS FOR
        if (wheelColliders[i].isGrounded) {
          maxWheels++;
          wheelColliders[i].GetGroundHit(out tempWheelHit);
          float maxTempSKid = Mathf.Abs(tempWheelHit.sidewaysSlip);
          if (Mathf.Abs(tempWheelHit.forwardSlip * _skidMarks.forwordSensibility) > maxTempSKid) {
            maxTempSKid = Mathf.Abs(tempWheelHit.forwardSlip * _skidMarks.forwordSensibility);
          }

          bool detectGroundOnThisFor = false;
          for (int x = 0; x < _groundSounds.groundSounds.Length; x++) {//SOUNDS FOR
            switch (_groundDetection) {
              case GroundDetectionMode.Tag:
                if (!string.IsNullOrEmpty(_groundSounds.groundSounds[x].groundTag)) {
                  if (tempWheelHit.collider.gameObject.CompareTag(_groundSounds.groundSounds[x].groundTag)) {
                    wheelsInOtherGround++;
                    if ((maxTempSKid > (1 / _skidMarks.sensibility)) || skidIsTrue) {
                      groundSoundsAUDSkid[x].volume = Mathf.Lerp(groundSoundsAUDSkid[x].volume, (slipForVolume * _groundSounds.groundSounds[x].volumeSkid), Time.deltaTime * 5.0f);
                      if (_groundSounds.groundSounds[x].skiddingSound) {
                        wheelEmitterSoundXSkid[x]++;
                        if (!groundSoundsAUDSkid[x].isPlaying && groundSoundsAUDSkid[x]) {
                          groundSoundsAUDSkid[x].PlayOneShot(groundSoundsAUDSkid[x].clip);
                        }
                      }
                    } else {
                      wheelBlockSoundXSkid[x]++;
                    }
                  } else {
                    wheelBlockSoundXSkid[x]++;
                  }
                } else {
                  wheelBlockSoundXSkid[x]++;
                }
                break;
              //==============================================================================================================================
              case GroundDetectionMode.PhysicMaterial:
                if (_groundSounds.groundSounds[x].physicMaterial) {
                  if (tempWheelHit.collider.sharedMaterial == _groundSounds.groundSounds[x].physicMaterial) {
                    wheelsInOtherGround++;
                    if ((maxTempSKid > (1 / _skidMarks.sensibility)) || skidIsTrue) {
                      groundSoundsAUDSkid[x].volume = Mathf.Lerp(groundSoundsAUDSkid[x].volume, (slipForVolume * _groundSounds.groundSounds[x].volumeSkid), Time.deltaTime * 5.0f);
                      if (_groundSounds.groundSounds[x].skiddingSound) {
                        wheelEmitterSoundXSkid[x]++;
                        if (!groundSoundsAUDSkid[x].isPlaying && groundSoundsAUDSkid[x]) {
                          groundSoundsAUDSkid[x].PlayOneShot(groundSoundsAUDSkid[x].clip);
                        }
                      }
                    } else {
                      wheelBlockSoundXSkid[x]++;
                    }
                  } else {
                    wheelBlockSoundXSkid[x]++;
                  }
                } else {
                  wheelBlockSoundXSkid[x]++;
                }
                break;
              //==============================================================================================================================
              case GroundDetectionMode.TerrainTextureIndices:
                if (activeTerrain_optional) {
                  if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                    int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                    if (dominantTerrainIndex != -1) {
                      if (_groundSounds.groundSounds[x].terrainTextureIndices.Count > 0 && _groundSounds.groundSounds[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                        wheelsInOtherGround++;
                        if ((maxTempSKid > (1 / _skidMarks.sensibility)) || skidIsTrue) {
                          groundSoundsAUDSkid[x].volume = Mathf.Lerp(groundSoundsAUDSkid[x].volume, (slipForVolume * _groundSounds.groundSounds[x].volumeSkid), Time.deltaTime * 5.0f);
                          if (_groundSounds.groundSounds[x].skiddingSound) {
                            wheelEmitterSoundXSkid[x]++;
                            if (!groundSoundsAUDSkid[x].isPlaying && groundSoundsAUDSkid[x]) {
                              groundSoundsAUDSkid[x].PlayOneShot(groundSoundsAUDSkid[x].clip);
                            }
                          }
                        } else {
                          wheelBlockSoundXSkid[x]++;
                        }
                      } else {
                        wheelBlockSoundXSkid[x]++;
                      }
                    } else {
                      wheelBlockSoundXSkid[x]++;
                    }
                  } else {
                    wheelBlockSoundXSkid[x]++;
                  }
                } else {
                  wheelBlockSoundXSkid[x]++;
                }
                break;
              //==============================================================================================================================
              case GroundDetectionMode.All:
                bool _emitterSoundXBool = false;
                bool _wheelsInOtherGround = false;
                if (!detectGroundOnThisFor) {
                  //tag
                  if (!string.IsNullOrEmpty(_groundSounds.groundSounds[x].groundTag)) {
                    if (tempWheelHit.collider.gameObject.CompareTag(_groundSounds.groundSounds[x].groundTag)) {
                      detectGroundOnThisFor = true;
                      _wheelsInOtherGround = true;
                      if ((maxTempSKid > (1 / _skidMarks.sensibility)) || skidIsTrue) {
                        groundSoundsAUDSkid[x].volume = Mathf.Lerp(groundSoundsAUDSkid[x].volume, (slipForVolume * _groundSounds.groundSounds[x].volumeSkid), Time.deltaTime * 5.0f);
                        if (_groundSounds.groundSounds[x].skiddingSound) {
                          _emitterSoundXBool = true;
                          if (!groundSoundsAUDSkid[x].isPlaying && groundSoundsAUDSkid[x]) {
                            groundSoundsAUDSkid[x].PlayOneShot(groundSoundsAUDSkid[x].clip);
                          }
                        }
                      }
                    }
                  }
                  //physicMaterial
                  if (!_wheelsInOtherGround) {
                    if (_groundSounds.groundSounds[x].physicMaterial) {
                      if (tempWheelHit.collider.sharedMaterial == _groundSounds.groundSounds[x].physicMaterial) {
                        detectGroundOnThisFor = true;
                        _wheelsInOtherGround = true;
                        if ((maxTempSKid > (1 / _skidMarks.sensibility)) || skidIsTrue) {
                          groundSoundsAUDSkid[x].volume = Mathf.Lerp(groundSoundsAUDSkid[x].volume, (slipForVolume * _groundSounds.groundSounds[x].volumeSkid), Time.deltaTime * 5.0f);
                          if (_groundSounds.groundSounds[x].skiddingSound) {
                            _emitterSoundXBool = true;
                            if (!groundSoundsAUDSkid[x].isPlaying && groundSoundsAUDSkid[x]) {
                              groundSoundsAUDSkid[x].PlayOneShot(groundSoundsAUDSkid[x].clip);
                            }
                          }
                        }
                      }
                    }
                  }
                  //terrainTextureIndice
                  if (!_wheelsInOtherGround) {
                    if (activeTerrain_optional) {
                      if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                        int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                        if (dominantTerrainIndex != -1) {
                          if (_groundSounds.groundSounds[x].terrainTextureIndices.Count > 0 && _groundSounds.groundSounds[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                            detectGroundOnThisFor = true;
                            _wheelsInOtherGround = true;
                            if ((maxTempSKid > (1 / _skidMarks.sensibility)) || skidIsTrue) {
                              groundSoundsAUDSkid[x].volume = Mathf.Lerp(groundSoundsAUDSkid[x].volume, (slipForVolume * _groundSounds.groundSounds[x].volumeSkid), Time.deltaTime * 5.0f);
                              if (_groundSounds.groundSounds[x].skiddingSound) {
                                _emitterSoundXBool = true;
                                if (!groundSoundsAUDSkid[x].isPlaying && groundSoundsAUDSkid[x]) {
                                  groundSoundsAUDSkid[x].PlayOneShot(groundSoundsAUDSkid[x].clip);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                //check
                if (_wheelsInOtherGround) {
                  wheelsInOtherGround++;
                }

                if (_emitterSoundXBool) {
                  wheelEmitterSoundXSkid[x]++;
                } else {
                  wheelBlockSoundXSkid[x]++;
                }
                //

                break;
                //==============================================================================================================================
            }
          }
        }
      }
      for (int x = 0; x < _groundSounds.groundSounds.Length; x++) {
        if (wheelBlockSoundXSkid[x] > 0 && wheelEmitterSoundXSkid[x] == 0 && groundSoundsAUDSkid[x]) {
          groundSoundsAUDSkid[x].volume = Mathf.Lerp(groundSoundsAUDSkid[x].volume, 0, Time.deltaTime * 5.0f);
          if (groundSoundsAUDSkid[x].volume < 0.6f) {
            groundSoundsAUDSkid[x].Stop();
          }
        }
      }
      if (wheelsInOtherGround >= maxWheels) {
        otherGround = true;
      }
      return otherGround;
    }

    void VehicleSoundsFunction() {
      //airBrakeSound
      if (_sounds.airBrakeSound) {
        if (_vehicleState == ControlState.isPlayer) {
          float brakeInput = 0.0f;
          if (automaticGears) {
            if (currentGear > 0) {
              brakeInput = Mathf.Abs(Mathf.Clamp(verticalInput, -1.0f, 0.0f)) * 1.5f;
            } else {
              brakeInput = Mathf.Abs(Mathf.Clamp(verticalInput, 0.0f, 1.0f)) * 1.5f;
            }
          } else {
            if ((currentGear < 0 && mediumRPM > 0) || (currentGear > 0 && mediumRPM < 0)) {
              brakeInput = Mathf.Abs(verticalInput);
            } else {
              brakeInput = Mathf.Abs(Mathf.Clamp(verticalInput, -1.0f, 0.0f));
            }
          }
          if (brakeInput > 0.8f) {
            boolTimeAirBrake = true;
          }
          if (brakeInput < 0.4f && boolTimeAirBrake) {
            if (!airBrakeSoundAUD.isPlaying) {
              airBrakeSoundAUD.PlayOneShot(airBrakeSoundAUD.clip);
            }
            boolTimeAirBrake = false;
          }
        }
      }

      //groundSounds
      if (_groundSounds.groundSounds.Length > 0) {
        if (_vehicleState == ControlState.isPlayer || KMh > 0.1f) {
          GroundSoundsEmitter(wheelColliderList);
        } else {
          for (int x = 0; x < _groundSounds.groundSounds.Length; x++) {
            if (groundSoundsAUD[x].isPlaying) {
              if (groundSoundsAUD[x]) {
                groundSoundsAUD[x].Stop();
              }
            }
          }
        }
      }

      //skiddingSound
      if (_groundSounds.standardSkidSound) {
        if (_vehicleState == ControlState.isPlayer || KMh > 0.1f) {
          SkiddingSounds();
        } else {
          skiddingSoundAUD.volume = Mathf.Lerp(skiddingSoundAUD.volume, 0, Time.deltaTime * 7.0f);
          if (skiddingSoundAUD.volume < 0.3f) {
            skiddingSoundAUD.Stop();
          }
          //
          for (int x = 0; x < _groundSounds.groundSounds.Length; x++) {
            if (groundSoundsAUDSkid[x]) {
              groundSoundsAUDSkid[x].volume = Mathf.Lerp(groundSoundsAUDSkid[x].volume, 0, Time.deltaTime * 5.0f);
              if (groundSoundsAUDSkid[x].volume < 0.6f) {
                groundSoundsAUDSkid[x].Stop();
              }
            }
          }
        }
      }

      //engineSound
      if (_sounds.engineSound) {
        if (theEngineIsRunning) {
          engineSoundAUD.volume = Mathf.Lerp(engineSoundAUD.volume, Mathf.Clamp(Mathf.Abs(verticalInput), 0.35f, 1.0f) * _sounds.volumeOfTheEngineSound, Time.deltaTime * 5.0f);

          pitchAUDforRPM = Mathf.Clamp(pitchAUDforRPM, 0.85f, _sounds.speedOfEngineSound);
          if (handBrakeTrue || currentGear == 0) {
            engineSoundAUD.pitch = Mathf.Lerp(engineSoundAUD.pitch, pitchAUDforRPM, Time.deltaTime * 5.0f);
          } else {
            //speed of the sound
            float minSpeedGear = 0;
            if (currentGear == -1 || currentGear == 0) {
              minSpeedGear = _vehicleTorque.minVelocityGears[0] * _vehicleTorque.speedOfGear;
            } else {
              minSpeedGear = _vehicleTorque.minVelocityGears[currentGear - 1] * _vehicleTorque.speedOfGear;
            }
            if (KMh < minSpeedGear) {
              speedLerpSound = 1.0f;
            } else {
              if (speedLerpSound < 4.9f) {
                speedLerpSound = Mathf.Lerp(speedLerpSound, 5.0f, Time.deltaTime * 2.0f);
              }
            }
            //set sound pitch
            engineSoundAUD.pitch = Mathf.Lerp(engineSoundAUD.pitch, pitchAUDforRPM, Time.deltaTime * speedLerpSound);
          }
        } else {
          if (enableEngineSound) {
            if (_sounds.engineStartSound) {
              engineSoundAUD.volume = 0;
            } else {
              engineSoundAUD.volume = _sounds.volumeOfTheEngineSound;
            }
            engineSoundAUD.pitch = Mathf.Lerp(engineSoundAUD.pitch, 0.7f, Time.deltaTime);
            pitchAUDforRPM = 0.7f;
          } else {
            engineSoundAUD.volume = Mathf.Lerp(engineSoundAUD.volume, 0f, Time.deltaTime);
            engineSoundAUD.pitch = Mathf.Lerp(engineSoundAUD.pitch, 0f, Time.deltaTime);
          }
        }
      }

      //other sounds
      if (_vehicleState == ControlState.isPlayer) {
        //hornSound
        if (_sounds.hornSound) { // hornIsOn
          if (hornIsOn && !hornSoundAUD.isPlaying) {
            hornSoundAUD.PlayOneShot(hornSoundAUD.clip);
            StartCoroutine(nameof(TimeHornSound));
          }
        }

        //nitroSound
        if (_sounds.nitroStartSound) {
          if (_additionalFeatures.nitroIsTrueVar && !nitroSoundWasPlayed) {
            nitroSoundWasPlayed = true;
            nitroSoundAUD.PlayOneShot(nitroSoundAUD.clip);
          }
          if (!_additionalFeatures.nitroIsTrueVar && nitroSoundWasPlayed) {
            nitroSoundWasPlayed = false;
          }
        }

        //handBrakeSound
        if (_sounds.handBrakeSound) {
          if (!handBrakeSoundAUD.isPlaying && handBrakeTrue && !handBrakeSoundWasPlayed) {
            handBrakeSoundWasPlayed = true;
            handBrakeSoundAUD.PlayOneShot(handBrakeSoundAUD.clip);
          }
          if (!handBrakeTrue && handBrakeSoundWasPlayed) {
            handBrakeSoundWasPlayed = false;
          }
        }

        //reverseSirenSound
        if (_sounds.reverseSirenSound) {
          if (currentGear == -1) {
            if (!sirenSoundAUD.isPlaying) {
              sirenSoundAUD.PlayOneShot(sirenSoundAUD.clip);
            }
          } else {
            sirenSoundAUD.Stop();
          }
        }
      }

      //windSound
      if (_sounds.windSound) {
        windSoundAUD.volume = Mathf.Clamp(ms_Rigidbody.velocity.magnitude * _sounds.sensibilityWindSound - 0.3f, 0.0f, 3.0f);
        if (ms_Rigidbody.velocity.magnitude > 15.0f) {
          if (!windSoundAUD.isPlaying && !windLoop) {
            windLoop = true;
            windSoundAUD.Play();
          }
        } else {
          windLoop = false;
          windSoundAUD.Stop();
        }
      }

      //wheelImpactSound
      if (_sounds.wheelImpactSound) {
        Vector3 posWheel;
        Quaternion rotWheel;
        float localPositionYAxis;

        // rightFrontWheel
        _wheels.rightFrontWheel.wheelCollider.GetWorldPose(out posWheel, out rotWheel);
        localPositionYAxis = transform.InverseTransformPoint(posWheel).y;
        if (Mathf.Abs(lastRightFrontPositionY - localPositionYAxis) > sensImpactFR) {
          beatsOnWheelSoundAUD.PlayOneShot(beatsOnWheelSoundAUD.clip);
        }
        lastRightFrontPositionY = localPositionYAxis;

        // leftFrontWheel
        _wheels.leftFrontWheel.wheelCollider.GetWorldPose(out posWheel, out rotWheel);
        localPositionYAxis = transform.InverseTransformPoint(posWheel).y;
        if (Mathf.Abs(lastLeftFrontPositionY - localPositionYAxis) > sensImpactFL) {
          beatsOnWheelSoundAUD.PlayOneShot(beatsOnWheelSoundAUD.clip);
        }
        lastLeftFrontPositionY = localPositionYAxis;

        // rightRearWheel
        _wheels.rightRearWheel.wheelCollider.GetWorldPose(out posWheel, out rotWheel);
        localPositionYAxis = transform.InverseTransformPoint(posWheel).y;
        if (Mathf.Abs(lastRightRearPositionY - localPositionYAxis) > sensImpactRR) {
          beatsOnWheelSoundAUD.PlayOneShot(beatsOnWheelSoundAUD.clip);
        }
        lastRightRearPositionY = localPositionYAxis;

        // leftRearWheel
        _wheels.leftRearWheel.wheelCollider.GetWorldPose(out posWheel, out rotWheel);
        localPositionYAxis = transform.InverseTransformPoint(posWheel).y;
        if (Mathf.Abs(lastLeftRearPositionY - localPositionYAxis) > sensImpactRL) {
          beatsOnWheelSoundAUD.PlayOneShot(beatsOnWheelSoundAUD.clip);
        }
        lastLeftRearPositionY = localPositionYAxis;

        // extra wheels
        for (int x = 0; x < _wheels.extraWheels.Length; x++) {
          _wheels.extraWheels[x].wheelCollider.GetWorldPose(out posWheel, out rotWheel);
          localPositionYAxis = transform.InverseTransformPoint(posWheel).y;
          if (Mathf.Abs(lastPositionYExtraWheels[x] - localPositionYAxis) > sensImpactExtraWheels[x]) {
            beatsOnWheelSoundAUD.PlayOneShot(beatsOnWheelSoundAUD.clip);
          }
          lastPositionYExtraWheels[x] = localPositionYAxis;
        }
      }

      //blinkingSound
      if (_sounds.blinkingSound) {
        if (rightBlinkersOn || leftBlinkersOn) {
          if (!flashingSoundAUD.isPlaying && !loopBlinkersOn) {
            loopBlinkersOn = true;
            flashingSoundAUD.Play();
          }
        } else {
          flashingSoundAUD.Stop();
          loopBlinkersOn = false;
        }
      }
    }
    IEnumerator TimeHornSound() {
      yield return new WaitForSeconds(hornSoundAUD.clip.length);
      hornIsOn = false;
    }

    public IEnumerator StartEngineCoroutine(bool startEngine) {
      if (startEngine) {
        youCanCall = false;
        yield return new WaitForSeconds(_vehicleSettings.delayToStartTheEngine);
        //
        youCanCall = true;
        _vehicleSettings.delayToStartTheEngine = previousDelayStartEngine;
        if (engineSoundAUD) {
          engineSoundAUD.volume = _sounds.volumeOfTheEngineSound;
        }
        if (currentFuelLiters > 0) {
          theEngineIsRunning = true;
        }
      } else {
        enableEngineSound = false;
        theEngineIsRunning = false;
        //
        youCanCall = false;
        yield return new WaitForSeconds(_vehicleSettings.delayToStartTheEngine * 0.8f);
        youCanCall = true;
        _vehicleSettings.delayToStartTheEngine = previousDelayStartEngine;
      }
    }

    public float collisionTimeout = 0.8f;
    public float lastCollisionTime = -1;
    public Collision lastCollision;

    public partial class VehicleCollisionEvent : UnityEvent<Collision> {
      
    }

    public VehicleCollisionEvent OnCollision = new();

    void HandleCollision(Collision collision) {
      float timeSinceStartup = Time.realtimeSinceStartup;
      if (timeSinceStartup < lastCollisionTime + collisionTimeout) {
        return;
      }
      OnCollision.Invoke(collision);
      lastCollision = collision;
      lastCollisionTime = timeSinceStartup;
    }

    void OnCollisionEnter(Collision collision) {
      if (collision.contacts.Length > 0) {
        if (collision.relativeVelocity.magnitude > 1) {
          if (collision.contacts[0].thisCollider.gameObject.transform != transform.parent) {
            //impact sound
            if (_sounds.collisionSounds.Length > 0) {
              beatsSoundAUD.clip = _sounds.collisionSounds[UnityEngine.Random.Range(0, _sounds.collisionSounds.Length)];
              beatsSoundAUD.PlayOneShot(beatsSoundAUD.clip);
              HandleCollision(collision);
            }
          }
        }
      }
    }



    public IEnumerator ChangeGears(int gear) {
      changinGears = true;
      if (gear == 1) {
        lastKnownTorque *= 1.2f;
      } else {
        lastKnownTorque *= 0.8f;
      }
      yield return new WaitForSeconds(_vehicleTorque.gearShiftTime);
      changinGears = false;
      currentGear = gear;
    }
    void AutomaticGears() {
      if (currentGear == 0) {
        if (mediumRPM >= 0 && mediumRPM < 5) {
          currentGear = 1;
        }
        if (mediumRPM > -5 && mediumRPM < 0) {
          currentGear = -1;
        }
      }
      if (Mathf.Abs(verticalInput) < 0.1f) {
        if (mediumRPM < -0.3f) {
          currentGear = -1;
        }
        if (mediumRPM >= 0 && currentGear < 2) {
          currentGear = 1;
        }
      }
      if (_vehicleState == ControlState.isPlayer) {
        if ((Mathf.Abs(Mathf.Clamp(verticalInput, -1f, 0f))) > 0.8f) {
          if ((KMh < 5 && mediumRPM < 1) || mediumRPM < -2) {
            currentGear = -1;
          }
        }
        if ((Mathf.Abs(Mathf.Clamp(verticalInput, 0f, 1f))) > 0.8f) {
          if ((KMh < 5) || (mediumRPM > 2 && currentGear < 2)) {
            currentGear = 1;
          }
        }
      } else {
        if ((Mathf.Abs(Mathf.Clamp(verticalInput, -1f, 0f))) > 0.05f) {
          if ((KMh < 5) || mediumRPM < -2) {
            currentGear = -1;
          }
        }
        if ((Mathf.Abs(Mathf.Clamp(verticalInput, 0f, 1f))) > 0.05f) {
          if ((KMh < 5) || (mediumRPM > 2 && currentGear < 2)) {
            currentGear = 1;
          }
        }
      }


      // 
      if (currentGear >= 1) {
        if (KMh > (_vehicleTorque.idealVelocityGears[currentGear - 1] * _vehicleTorque.speedOfGear + 17.5f * _vehicleTorque.speedOfGear)) {
          if (currentGear < _vehicleTorque.numberOfGears && !changinGearsAuto) {                     //here, have !changinGearsAuto condition
            StartCoroutine(TimeAutoGears(currentGear + 1, _vehicleTorque.gearShiftTime, 1.5f));
          }
        } else if (KMh < (_vehicleTorque.idealVelocityGears[currentGear - 1] * _vehicleTorque.speedOfGear - 20 * _vehicleTorque.speedOfGear)) {
          if (currentGear > 1 && !changinGearsAuto) {
            StartCoroutine(TimeAutoGears(currentGear - 1, (_vehicleTorque.gearShiftTime * 0.5f), 0.0f));
          }
        }
        //
        if (verticalInput > 0.1f && KMh > (_vehicleTorque.idealVelocityGears[currentGear - 1] * _vehicleTorque.speedOfGear + 17.5f * _vehicleTorque.speedOfGear)) {
          if (currentGear < _vehicleTorque.numberOfGears) {                                          //here, not have !changinGearsAuto condition
            StartCoroutine(TimeAutoGears(currentGear + 1, _vehicleTorque.gearShiftTime, 0.0f));
          }
        }
      }
    }
    IEnumerator TimeAutoGears(int gear, float changeGearTime, float waitingTime) {
      changinGearsAuto = true;
      if (gear == 0) {
        lastKnownTorque = lastKnownTorque * 1.2f;
      } else {
        lastKnownTorque = lastKnownTorque * 0.8f;
      }
      yield return new WaitForSeconds(changeGearTime);
      currentGear = gear;
      yield return new WaitForSeconds(waitingTime);
      changinGearsAuto = false;
    }



    float SteerAngleOptimized(float clampHorizontalInput) {
      float v3Dot_speed = Vector3.Dot(ms_Rigidbody.velocity, transform.forward);
      float dot_factor = Mathf.InverseLerp(0.1f, 3.0f, v3Dot_speed);
      float speedAngle = Mathf.Sign(Vector3.Dot(ms_Rigidbody.velocity, transform.right)) * Vector3.Angle(ms_Rigidbody.velocity, transform.forward);
      float assistAngle = 0.0f;
      if (_steeringWheel.steeringAssist > 0.1f) {
        assistAngle = speedAngle * dot_factor * Mathf.InverseLerp(2.0f, 3.0f, Mathf.Abs(speedAngle)) * _steeringWheel.steeringAssist;
      }
      float inputSteering = _steeringWheel.maxAngle * clampHorizontalInput;
      if (_steeringWheel.steeringLimit > 0.1f) {
        float forwardSpeed = v3Dot_speed * dot_factor * _steeringWheel.steeringLimit;
        float maxEspAngle = Mathf.Rad2Deg * Mathf.Asin(Mathf.Clamp((3.0f / forwardSpeed), 0, 1));
        float steerAngleLimit = Mathf.Min(_steeringWheel.maxAngle, Mathf.Max(maxEspAngle, Mathf.Abs(speedAngle)));
        inputSteering = Mathf.Clamp(inputSteering, -steerAngleLimit, steerAngleLimit);
      }
      float finalAngle = Mathf.Clamp(inputSteering + assistAngle, -_steeringWheel.maxAngle, _steeringWheel.maxAngle);
      return finalAngle;
    }
    void VehicleSteeringWheel() {
      if (_vehicleState == ControlState.isPlayer) {
        //get steering wheel inputs
        if (_steeringWheel.keepRotated) {
          volantDir_horizontalInput += horizontalInput * fixedDeltaTime * _steeringWheel.steeringWheelSpeed;
          volantDir_horizontalInput = Mathf.Clamp(volantDir_horizontalInput, -1.0f, 1.0f);
          if (Mathf.Abs(volantDir_horizontalInput) < 0.15f) {
            volantDir_horizontalInput = Mathf.Lerp(volantDir_horizontalInput, 0, fixedDeltaTime * 0.5f);
          }
        } else {
          volantDir_horizontalInput = horizontalInput;
        }

        angleSteeringClamp = Mathf.MoveTowards(angleSteeringClamp, volantDir_horizontalInput, _steeringWheel.steeringWheelSpeed * fixedDeltaTime);
        float newFinalAngleDegress = SteerAngleOptimized(angleSteeringClamp);
        if (_steeringWheel.useLerp) {
          finalAngleDegress = Mathf.Lerp(finalAngleDegress, newFinalAngleDegress, fixedDeltaTime * 5.0f); //(0.02f * 5) = 0.1f per frame
        } else {
          finalAngleDegress = newFinalAngleDegress;
        }
      }

      //APPLY ANGLE IN WHEELS--------------------------------------------------------------------------------------------------------------
      if (_wheels.rightFrontWheel.wheelTurn) {
        float angleMultiplFactor = _wheels.rightFrontWheel.angleFactor;
        if (_wheels.rightFrontWheel.reverseTurn) {
          angleMultiplFactor *= -1;
        }
        _wheels.rightFrontWheel.wheelCollider.steerAngle = finalAngleDegress * angleMultiplFactor;
      }
      if (_wheels.leftFrontWheel.wheelTurn) {
        float angleMultiplFactor = _wheels.leftFrontWheel.angleFactor;
        if (_wheels.leftFrontWheel.reverseTurn) {
          angleMultiplFactor *= -1;
        }
        _wheels.leftFrontWheel.wheelCollider.steerAngle = finalAngleDegress * angleMultiplFactor;
      }
      if (_wheels.rightRearWheel.wheelTurn) {
        float angleMultiplFactor = _wheels.rightRearWheel.angleFactor;
        if (_wheels.rightRearWheel.reverseTurn) {
          angleMultiplFactor *= -1;
        }
        _wheels.rightRearWheel.wheelCollider.steerAngle = finalAngleDegress * angleMultiplFactor;
      }
      if (_wheels.leftRearWheel.wheelTurn) {
        float angleMultiplFactor = _wheels.leftRearWheel.angleFactor;
        if (_wheels.leftRearWheel.reverseTurn) {
          angleMultiplFactor *= -1;
        }
        _wheels.leftRearWheel.wheelCollider.steerAngle = finalAngleDegress * angleMultiplFactor;
      }
      for (int x = 0; x < _wheels.extraWheels.Length; x++) {
        if (_wheels.extraWheels[x].wheelTurn) {
          float angleMultiplFactor = _wheels.extraWheels[x].angleFactor;
          if (_wheels.extraWheels[x].reverseTurn) {
            angleMultiplFactor *= -1;
          }
          _wheels.extraWheels[x].wheelCollider.steerAngle = finalAngleDegress * angleMultiplFactor;
        }
      }
      //

      if (_steeringWheel.steeringWheelObject) {
        float returnAngleToAssistInput = finalAngleDegress / _steeringWheel.maxAngle;
        angleVolantIntern = Mathf.MoveTowards(angleVolantIntern, returnAngleToAssistInput, _steeringWheel.steeringWheelSpeed * fixedDeltaTime);
        int reverseRotationVolant = 1;
        if (_steeringWheel.invertRotation) {
          reverseRotationVolant = -1;
        }
        //
        switch (_steeringWheel.rotationType) {
          case VolantSettingsClass.SelectRotation.RotationInY:
            _steeringWheel.steeringWheelObject.transform.localEulerAngles = new Vector3(_steeringWheel.steeringWheelObject.transform.localEulerAngles.x, volantStartRotation + (angleVolantIntern * reverseRotationVolant * (360.0f * _steeringWheel.numberOfTurns)), _steeringWheel.steeringWheelObject.transform.localEulerAngles.z);
            break;
          case VolantSettingsClass.SelectRotation.RotationInZ:
            _steeringWheel.steeringWheelObject.transform.localEulerAngles = new Vector3(_steeringWheel.steeringWheelObject.transform.localEulerAngles.x, _steeringWheel.steeringWheelObject.transform.localEulerAngles.y, volantStartRotation + (angleVolantIntern * reverseRotationVolant * (360.0f * _steeringWheel.numberOfTurns)));
            break;
        }
      }
      if (disableBlinkers1 && angleSteeringClamp > 0.6f && rightBlinkersOn) {
        disableBlinkers2 = true;
      }
      if (disableBlinkers1 && angleSteeringClamp < -0.6f && leftBlinkersOn) {
        disableBlinkers2 = true;
      }
      if ((angleSteeringClamp > -0.1f && angleSteeringClamp < 0.1f) && (rightBlinkersOn || leftBlinkersOn) && disableBlinkers2) {
        rightBlinkersOn = leftBlinkersOn = false;
        disableBlinkers2 = false;
        disableBlinkers1 = false;
      }
    }



    public float VehicleTorque(WheelCollider wheelCollider, float torqueInfluence) {
      float torqueToLerp = 0;
      float rpmTempTorque = Mathf.Abs(wheelCollider.rpm);
      if ((Mathf.Abs(verticalInput) < 0.05f) || KMh > _vehicleTorque.maxVelocityKMh) {
        return 0;
      }
      if ((rpmTempTorque * wheelCollider.radius) > 99999) {
        return 0;
      }
      if (KMh < 0.5f) {
        if (rpmTempTorque > (25.0f / wheelCollider.radius)) {
          return 0;
        }
      }
      if (!theEngineIsRunning || handBrakeTrue || isBraking) {
        return 0;
      }
      if (changinGears) {
        return 0;
      }

      //

      float vehicleTorque_x_Mass = (_vehicleSettings.vehicleMass * _vehicleTorque.engineTorque);
      float tempPoint_Evaluate = KMh / _vehicleTorque.speedOfGear;

      if (currentGear < 0) {
        if (automaticGears) {
          float clampInputTorque = Mathf.Clamp(verticalInput, -1, 0);
          torqueToLerp = 0.8f * vehicleTorque_x_Mass * clampInputTorque * (_vehicleTorque.gearsArray[0].Evaluate(tempPoint_Evaluate)); // reverse gear automatic
        } else {
          float clampInputTorque = Mathf.Clamp(verticalInput, 0, 1);
          torqueToLerp = 0.8f * vehicleTorque_x_Mass * -clampInputTorque * (_vehicleTorque.gearsArray[0].Evaluate(tempPoint_Evaluate)); // reverse gear manual
        }
      } else if (currentGear == 0) {
        return 0; // neutral gear
      } else {
        torqueToLerp = vehicleTorque_x_Mass * (Mathf.Clamp(verticalInput, 0, 1)) * _vehicleTorque.gearsArray[currentGear - 1].Evaluate(tempPoint_Evaluate); // other gears
      }



      //torque lerp
      if ((lastKnownTorque < 0 && torqueToLerp > 0) || (lastKnownTorque > 0 && torqueToLerp < 0)) {
        lastKnownTorque = 0.0f; //evita delay do torque ao trocar entre ré e primeira.
      }
      lastKnownTorque = Mathf.Lerp(lastKnownTorque, torqueToLerp, fixedDeltaTime * _vehicleTorque.speedEngineTorque);

      //ground torque factor
      float groundTorqueFactor = 1.0f;
      wheelCollider.GetGroundHit(out tempWheelHit);
      if (wheelCollider.isGrounded) {
        bool changeTorqueFactor = false;
        for (int x = 0; x < _groundFriction.grounds.Length; x++) {
          if (!changeTorqueFactor) {
            switch (_groundDetection) {
              case GroundDetectionMode.Tag:
                if (!string.IsNullOrEmpty(_groundFriction.grounds[x].groundTag)) {
                  if (tempWheelHit.collider.gameObject.CompareTag(_groundFriction.grounds[x].groundTag)) {
                    groundTorqueFactor = _groundFriction.grounds[x].torqueInThisGround;
                    changeTorqueFactor = true;
                    break;
                  }
                }
                break;
              //==============================================================================================================================
              case GroundDetectionMode.PhysicMaterial:
                if (_groundFriction.grounds[x].physicMaterial) {
                  if (tempWheelHit.collider.sharedMaterial == _groundFriction.grounds[x].physicMaterial) {
                    groundTorqueFactor = _groundFriction.grounds[x].torqueInThisGround;
                    changeTorqueFactor = true;
                    break;
                  }
                }
                break;
              //==============================================================================================================================
              case GroundDetectionMode.TerrainTextureIndices:
                if (activeTerrain_optional) {
                  if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                    int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                    if (dominantTerrainIndex != -1) {
                      if (_groundFriction.grounds[x].terrainTextureIndices.Count > 0 && _groundFriction.grounds[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                        groundTorqueFactor = _groundFriction.grounds[x].torqueInThisGround;
                        changeTorqueFactor = true;
                        break;
                      }
                    }
                  }
                }
                break;
              //==============================================================================================================================
              case GroundDetectionMode.All:
                //tag
                if (!string.IsNullOrEmpty(_groundFriction.grounds[x].groundTag)) {
                  if (tempWheelHit.collider.gameObject.CompareTag(_groundFriction.grounds[x].groundTag)) {
                    groundTorqueFactor = _groundFriction.grounds[x].torqueInThisGround;
                    changeTorqueFactor = true;
                    break;
                  }
                }
                //physicMaterial
                if (_groundFriction.grounds[x].physicMaterial) {
                  if (tempWheelHit.collider.sharedMaterial == _groundFriction.grounds[x].physicMaterial) {
                    groundTorqueFactor = _groundFriction.grounds[x].torqueInThisGround;
                    changeTorqueFactor = true;
                    break;
                  }
                }
                //terrainTextureIndice
                if (activeTerrain_optional) {
                  if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                    int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                    if (dominantTerrainIndex != -1) {
                      if (_groundFriction.grounds[x].terrainTextureIndices.Count > 0 && _groundFriction.grounds[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                        groundTorqueFactor = _groundFriction.grounds[x].torqueInThisGround;
                        changeTorqueFactor = true;
                        break;
                      }
                    }
                  }
                }
                break;
                //==============================================================================================================================
            }
          }
        }
      }

      //damage adjustment
      float damageFactorTorque = 1;

      // compute torque
      float nitroFactor = 1;
      if (_additionalFeatures.useNitro && _additionalFeatures.nitroIsTrueVar) {
        nitroFactor = _additionalFeatures.additionalNitroTorque;
      }
      float adjustTorqueByGear = Mathf.Clamp((1 + _vehicleTorque.decreaseTorqueByGear) - (Mathf.Abs(currentGear) * _vehicleTorque.decreaseTorqueByGear), 0.3f, 1.0f);
      float computedTorque = lastKnownTorque * groundTorqueFactor * vehicleScale * adjustTorqueByGear * damageFactorTorque * torqueInfluence * nitroFactor;
      if (_vehicleState == ControlState.isPlayer) {
        float finalTorque = computedTorque + (computedTorque * rpmTorqueFactor);
        return finalTorque;
      } else {
        return computedTorque;
      }
    }

    void ApplyTorque() {
      //motor torque
      if ((theEngineIsRunning && _vehicleState == ControlState.isPlayer)) {
        float leftAngularDifferential = 1 + Mathf.Abs((0.2f * Mathf.Abs(Mathf.Clamp(volantDir_horizontalInput, 0, 1))) * (finalAngleDegress / 60)) * _wheels.differentialInfluence;
        float rightAngularDifferential = 1 + Mathf.Abs((0.2f * Mathf.Abs(Mathf.Clamp(volantDir_horizontalInput, -1, 0))) * (finalAngleDegress / 60)) * _wheels.differentialInfluence;
        //
        if (_wheels.rightFrontWheel.wheelDrive) {
          _wheels.rightFrontWheel.wheelCollider.motorTorque = VehicleTorque(_wheels.rightFrontWheel.wheelCollider, _wheels.rightFrontWheel.torqueFactor) * rightAngularDifferential;
        }
        if (_wheels.leftFrontWheel.wheelDrive) {
          _wheels.leftFrontWheel.wheelCollider.motorTorque = VehicleTorque(_wheels.leftFrontWheel.wheelCollider, _wheels.leftFrontWheel.torqueFactor) * leftAngularDifferential;
        }
        if (_wheels.rightRearWheel.wheelDrive) {
          _wheels.rightRearWheel.wheelCollider.motorTorque = VehicleTorque(_wheels.rightRearWheel.wheelCollider, _wheels.rightRearWheel.torqueFactor) * rightAngularDifferential;
        }
        if (_wheels.leftRearWheel.wheelDrive) {
          _wheels.leftRearWheel.wheelCollider.motorTorque = VehicleTorque(_wheels.leftRearWheel.wheelCollider, _wheels.leftRearWheel.torqueFactor) * leftAngularDifferential;
        }
        for (int x = 0; x < _wheels.extraWheels.Length; x++) {
          if (_wheels.extraWheels[x].wheelDrive) {
            switch (_wheels.extraWheels[x].wheelPosition) {
              case WheelClass.WheelPosition.Right:
                _wheels.extraWheels[x].wheelCollider.motorTorque = VehicleTorque(_wheels.extraWheels[x].wheelCollider, _wheels.extraWheels[x].torqueFactor) * rightAngularDifferential;
                break;
              case WheelClass.WheelPosition.Left:
                _wheels.extraWheels[x].wheelCollider.motorTorque = VehicleTorque(_wheels.extraWheels[x].wheelCollider, _wheels.extraWheels[x].torqueFactor) * leftAngularDifferential;
                break;
            }
          }
        }
      } else {
        if (_wheels.rightFrontWheel.wheelDrive) {
          _wheels.rightFrontWheel.wheelCollider.motorTorque = 0;
        }
        if (_wheels.leftFrontWheel.wheelDrive) {
          _wheels.leftFrontWheel.wheelCollider.motorTorque = 0;
        }
        if (_wheels.rightRearWheel.wheelDrive) {
          _wheels.rightRearWheel.wheelCollider.motorTorque = 0;
        }
        if (_wheels.leftRearWheel.wheelDrive) {
          _wheels.leftRearWheel.wheelCollider.motorTorque = 0;
        }
        for (int x = 0; x < _wheels.extraWheels.Length; x++) {
          if (_wheels.extraWheels[x].wheelDrive) {
            _wheels.extraWheels[x].wheelCollider.motorTorque = 0;
          }
        }
      }
    }



    void Brakes() {
      float brakeVerticalInput = 0.0f;
      float currentBrakeValue = 0.0f;
      float handBrake_Input = 0.0f;

      //handBrake
      if (_vehicleState == ControlState.isPlayer) {
        if (handBrakeTrue) {
          handBrake_Input = 1;
        }
      }
      if (automaticGears) {
        if (handBrakeTrue) {
          handBrake_Input = 1;
        }
      }
      if (_brakes.handBrakeLock) {
        handBrake_Input *= 1000;
      }


      // pedal brake
      if (_vehicleState == ControlState.isPlayer) {
        brakeVerticalInput = verticalInput;
        if (Mathf.Abs(brakeVerticalInput) < 0.05f) {
          brakeVerticalInput = 0;
        }
        if (automaticGears) {
          if (currentGear > 0) {
            currentBrakeValue = Mathf.Abs(Mathf.Clamp(brakeVerticalInput, -1.0f, 0.0f));
          } else if (currentGear < 0) {
            currentBrakeValue = Mathf.Abs(Mathf.Clamp(brakeVerticalInput, 0.0f, 1.0f));
          } else if (currentGear == 0) {
            if (mediumRPM > 0) {
              currentBrakeValue = Mathf.Abs(Mathf.Clamp(brakeVerticalInput, -1.0f, 0.0f));
            } else {
              currentBrakeValue = Mathf.Abs(Mathf.Clamp(brakeVerticalInput, 0.0f, 1.0f));
            }
          }
        } else {
          currentBrakeValue = Mathf.Abs(Mathf.Clamp(brakeVerticalInput, -1.0f, 0.0f));
        }
      }

      //compute total brake
      float totalFootBrake = currentBrakeValue * _brakes.vehicleBrakingForce * _vehicleSettings.vehicleMass;
      float totalHandBrake = handBrake_Input * _brakes.vehicleBrakingForce * _vehicleSettings.vehicleMass * 2.0f;

      //auto brake
      if (_vehicleState == ControlState.isPlayer) {
        float autoBrakeInputValue = 0.5f;
        if (_brakes.brakingWithLowRpm && wheelFDIsGrounded && wheelFEIsGrounded && wheelTDIsGrounded && wheelTEIsGrounded) {
          if (Mathf.Abs(mediumRPM) < 15.0f && Mathf.Abs(brakeVerticalInput) < autoBrakeInputValue && !handBrakeTrue && (totalFootBrake + totalHandBrake) < 100.0f) {
            brakingAuto = true;
            totalFootBrake = 5.0f * _brakes.vehicleBrakingForce * _vehicleSettings.vehicleMass;
          } else {
            brakingAuto = false;
          }
        } else {
          brakingAuto = false;
        }
      } else {
        brakingAuto = false;
      }

      isBraking = totalFootBrake > 1;

      //cancel brakeForces for ABS
      if (_brakes.ABS && !brakingAuto) {
        if (isBraking && Mathf.Abs(KMh) > 1.2f) {
          totalFootBrake = 0;
        }
      }

      //apply computed brake forces
      ApplyBrakeInWheels(_wheels.rightFrontWheel.wheelCollider, _wheels.rightFrontWheel.wheelHandBrake, totalHandBrake, totalFootBrake);
      ApplyBrakeInWheels(_wheels.leftFrontWheel.wheelCollider, _wheels.leftFrontWheel.wheelHandBrake, totalHandBrake, totalFootBrake);
      ApplyBrakeInWheels(_wheels.rightRearWheel.wheelCollider, _wheels.rightRearWheel.wheelHandBrake, totalHandBrake, totalFootBrake);
      ApplyBrakeInWheels(_wheels.leftRearWheel.wheelCollider, _wheels.leftRearWheel.wheelHandBrake, totalHandBrake, totalFootBrake);
      for (int x = 0; x < _wheels.extraWheels.Length; x++) {
        ApplyBrakeInWheels(_wheels.extraWheels[x].wheelCollider, _wheels.extraWheels[x].wheelHandBrake, totalHandBrake, totalFootBrake);
      }
    }

    void ApplyBrakeInWheels(WheelCollider wheelCollider, bool handBrake, float sumHandBrake, float sumFootBrake) {
      if (_vehicleState == ControlState.isPlayer) {
        if (_brakes.brakeSlowly) {
          if (sumFootBrake == 0) {
            if (handBrake) {
              wheelCollider.brakeTorque = sumHandBrake;
            } else {
              wheelCollider.brakeTorque = 0.0f;
            }
          } else {
            if (handBrake) {
              wheelCollider.brakeTorque = Mathf.Lerp(wheelCollider.brakeTorque, sumFootBrake + sumHandBrake, fixedDeltaTime * _brakes.speedBrakeSlowly);
            } else {
              wheelCollider.brakeTorque = Mathf.Lerp(wheelCollider.brakeTorque, sumFootBrake, fixedDeltaTime * _brakes.speedBrakeSlowly);
            }
          }
        } else {
          if (handBrake) {
            wheelCollider.brakeTorque = sumFootBrake + sumHandBrake;
          } else {
            wheelCollider.brakeTorque = sumFootBrake;
          }
        }
      } else {
        if ((wheelCollider.brakeTorque < sumHandBrake) && handBrake) {
          if (_brakes.brakeSlowly) {
            wheelCollider.brakeTorque = Mathf.Lerp(wheelCollider.brakeTorque, sumHandBrake, fixedDeltaTime * _brakes.speedBrakeSlowly);
          } else {
            wheelCollider.brakeTorque = sumHandBrake;
          }
        }
      }
      // 

      //avoid RPM, brake or invalid torques, Avoid Torque-free Rotation
      if (wheelCollider.brakeTorque < 900000000) {
        if (!wheelCollider.isGrounded) {
          if (Mathf.Abs(wheelCollider.rpm) > 0.5f && Mathf.Abs(verticalInput) < 0.05f && wheelCollider.motorTorque < 5.0f) {
            wheelCollider.brakeTorque += _vehicleSettings.vehicleMass * _brakes.vehicleBrakingForce * fixedDeltaTime * 100;
          }
        }
        if (wheelCollider.isGrounded) {
          if (_vehicleState == ControlState.isNull && _brakes.brakeOnExitingTheVehicle && KMh < 0.5f) {
            wheelCollider.brakeTorque += _vehicleSettings.vehicleMass * _brakes.vehicleBrakingForce * fixedDeltaTime * 100;
          }
        }
        if (KMh < 0.5f && Mathf.Abs(verticalInput) < 0.05f) {
          if (wheelCollider.rpm > (25 / wheelCollider.radius)) {
            wheelCollider.brakeTorque += _brakes.vehicleBrakingForce * _vehicleSettings.vehicleMass * Mathf.Abs(wheelCollider.rpm) * fixedDeltaTime;
          }
        }
      }
    }

    public void SetWheelCollidersOnStart() {
      //forces
      _wheels.rightFrontWheel.wheelCollider.wheelDampingRate = 0.75f;
      _wheels.rightFrontWheel.wheelCollider.forceAppPointDistance = _suspension.forceAppPointDistance;
      _wheels.leftFrontWheel.wheelCollider.wheelDampingRate = 0.75f;
      _wheels.leftFrontWheel.wheelCollider.forceAppPointDistance = _suspension.forceAppPointDistance;
      _wheels.rightRearWheel.wheelCollider.wheelDampingRate = 0.75f;
      _wheels.rightRearWheel.wheelCollider.forceAppPointDistance = _suspension.forceAppPointDistance;
      _wheels.leftRearWheel.wheelCollider.wheelDampingRate = 0.75f;
      _wheels.leftRearWheel.wheelCollider.forceAppPointDistance = _suspension.forceAppPointDistance;

      //suspension spring
      JointSpring suspensionSpringg = new JointSpring();
      suspensionSpringg.spring = _suspension.suspensionHardness;
      suspensionSpringg.damper = _suspension.suspensionSwing;
      suspensionSpringg.targetPosition = 0.5f;
      _wheels.rightFrontWheel.wheelCollider.suspensionSpring = suspensionSpringg;
      _wheels.leftFrontWheel.wheelCollider.suspensionSpring = suspensionSpringg;
      _wheels.rightRearWheel.wheelCollider.suspensionSpring = suspensionSpringg;
      _wheels.leftRearWheel.wheelCollider.suspensionSpring = suspensionSpringg;

      //extra wheels FOR
      for (int x = 0; x < _wheels.extraWheels.Length; x++) {
        //suspension and rate
        _wheels.extraWheels[x].wheelCollider.wheelDampingRate = 0.75f;
        _wheels.extraWheels[x].wheelCollider.forceAppPointDistance = _suspension.forceAppPointDistance;
        //suspension spring
        _wheels.extraWheels[x].wheelCollider.suspensionSpring = suspensionSpringg;
        //mass and height
        _wheels.extraWheels[x].wheelCollider.mass = _wheels.wheelMass;
        _wheels.extraWheels[x].wheelCollider.suspensionDistance = _suspension.constVehicleHeightStart;
      }

      //mass
      _wheels.rightFrontWheel.wheelCollider.mass = _wheels.wheelMass;
      _wheels.leftFrontWheel.wheelCollider.mass = _wheels.wheelMass;
      _wheels.rightRearWheel.wheelCollider.mass = _wheels.wheelMass;
      _wheels.leftRearWheel.wheelCollider.mass = _wheels.wheelMass;

      //height
      _wheels.rightFrontWheel.wheelCollider.suspensionDistance = _suspension.constVehicleHeightStart;
      _wheels.leftFrontWheel.wheelCollider.suspensionDistance = _suspension.constVehicleHeightStart;
      _wheels.rightRearWheel.wheelCollider.suspensionDistance = _suspension.constVehicleHeightStart;
      _wheels.leftRearWheel.wheelCollider.suspensionDistance = _suspension.constVehicleHeightStart;
      //

      //Set friction in wheels
      if (_wheels.setFrictionByCode) {
        SetWheelColliderFrictionOnStart(_wheels.rightFrontWheel.wheelCollider, _wheels.rightFrontWheel.useCustomFriction,
          _wheels.rightFrontWheel.adjustCustomFriction.ForwardFriction.ExtremumSlip,
          _wheels.rightFrontWheel.adjustCustomFriction.ForwardFriction.ExtremumValue,
          _wheels.rightFrontWheel.adjustCustomFriction.ForwardFriction.AsymptoteSlip,
          _wheels.rightFrontWheel.adjustCustomFriction.ForwardFriction.AsymptoteValue,
          _wheels.rightFrontWheel.adjustCustomFriction.SidewaysFriction.ExtremumSlip,
          _wheels.rightFrontWheel.adjustCustomFriction.SidewaysFriction.ExtremumValue,
          _wheels.rightFrontWheel.adjustCustomFriction.SidewaysFriction.AsymptoteSlip,
          _wheels.rightFrontWheel.adjustCustomFriction.SidewaysFriction.AsymptoteValue);

        SetWheelColliderFrictionOnStart(_wheels.rightRearWheel.wheelCollider, _wheels.rightRearWheel.useCustomFriction,
          _wheels.rightRearWheel.adjustCustomFriction.ForwardFriction.ExtremumSlip,
          _wheels.rightRearWheel.adjustCustomFriction.ForwardFriction.ExtremumValue,
          _wheels.rightRearWheel.adjustCustomFriction.ForwardFriction.AsymptoteSlip,
          _wheels.rightRearWheel.adjustCustomFriction.ForwardFriction.AsymptoteValue,
          _wheels.rightRearWheel.adjustCustomFriction.SidewaysFriction.ExtremumSlip,
          _wheels.rightRearWheel.adjustCustomFriction.SidewaysFriction.ExtremumValue,
          _wheels.rightRearWheel.adjustCustomFriction.SidewaysFriction.AsymptoteSlip,
          _wheels.rightRearWheel.adjustCustomFriction.SidewaysFriction.AsymptoteValue);

        SetWheelColliderFrictionOnStart(_wheels.leftFrontWheel.wheelCollider, _wheels.leftFrontWheel.useCustomFriction,
          _wheels.leftFrontWheel.adjustCustomFriction.ForwardFriction.ExtremumSlip,
          _wheels.leftFrontWheel.adjustCustomFriction.ForwardFriction.ExtremumValue,
          _wheels.leftFrontWheel.adjustCustomFriction.ForwardFriction.AsymptoteSlip,
          _wheels.leftFrontWheel.adjustCustomFriction.ForwardFriction.AsymptoteValue,
          _wheels.leftFrontWheel.adjustCustomFriction.SidewaysFriction.ExtremumSlip,
          _wheels.leftFrontWheel.adjustCustomFriction.SidewaysFriction.ExtremumValue,
          _wheels.leftFrontWheel.adjustCustomFriction.SidewaysFriction.AsymptoteSlip,
          _wheels.leftFrontWheel.adjustCustomFriction.SidewaysFriction.AsymptoteValue);

        SetWheelColliderFrictionOnStart(_wheels.leftRearWheel.wheelCollider, _wheels.leftRearWheel.useCustomFriction,
          _wheels.leftRearWheel.adjustCustomFriction.ForwardFriction.ExtremumSlip,
          _wheels.leftRearWheel.adjustCustomFriction.ForwardFriction.ExtremumValue,
          _wheels.leftRearWheel.adjustCustomFriction.ForwardFriction.AsymptoteSlip,
          _wheels.leftRearWheel.adjustCustomFriction.ForwardFriction.AsymptoteValue,
          _wheels.leftRearWheel.adjustCustomFriction.SidewaysFriction.ExtremumSlip,
          _wheels.leftRearWheel.adjustCustomFriction.SidewaysFriction.ExtremumValue,
          _wheels.leftRearWheel.adjustCustomFriction.SidewaysFriction.AsymptoteSlip,
          _wheels.leftRearWheel.adjustCustomFriction.SidewaysFriction.AsymptoteValue);

        for (int x = 0; x < _wheels.extraWheels.Length; x++) {
          SetWheelColliderFrictionOnStart(_wheels.extraWheels[x].wheelCollider, _wheels.extraWheels[x].useCustomFriction,
            _wheels.extraWheels[x].adjustCustomFriction.ForwardFriction.ExtremumSlip,
            _wheels.extraWheels[x].adjustCustomFriction.ForwardFriction.ExtremumValue,
            _wheels.extraWheels[x].adjustCustomFriction.ForwardFriction.AsymptoteSlip,
            _wheels.extraWheels[x].adjustCustomFriction.ForwardFriction.AsymptoteValue,
            _wheels.extraWheels[x].adjustCustomFriction.SidewaysFriction.ExtremumSlip,
            _wheels.extraWheels[x].adjustCustomFriction.SidewaysFriction.ExtremumValue,
            _wheels.extraWheels[x].adjustCustomFriction.SidewaysFriction.AsymptoteSlip,
            _wheels.extraWheels[x].adjustCustomFriction.SidewaysFriction.AsymptoteValue);
        }
      }
    }
    public void SetGeneralSuspensionHeight() {
      float height = _suspension.vehicleCustomHeights[_suspension.indexCustomSuspensionHeight];
      if (_wheels.rightFrontWheel.wheelCollider.suspensionDistance != height) {
        _wheels.rightFrontWheel.wheelCollider.suspensionDistance = Mathf.MoveTowards(_wheels.rightFrontWheel.wheelCollider.suspensionDistance, height, fixedDeltaTime);
      }
      if (_wheels.leftFrontWheel.wheelCollider.suspensionDistance != height) {
        _wheels.leftFrontWheel.wheelCollider.suspensionDistance = Mathf.MoveTowards(_wheels.leftFrontWheel.wheelCollider.suspensionDistance, height, fixedDeltaTime);
      }
      if (_wheels.rightRearWheel.wheelCollider.suspensionDistance != height) {
        _wheels.rightRearWheel.wheelCollider.suspensionDistance = Mathf.MoveTowards(_wheels.rightRearWheel.wheelCollider.suspensionDistance, height, fixedDeltaTime);
      }
      if (_wheels.leftRearWheel.wheelCollider.suspensionDistance != height) {
        _wheels.leftRearWheel.wheelCollider.suspensionDistance = Mathf.MoveTowards(_wheels.leftRearWheel.wheelCollider.suspensionDistance, height, fixedDeltaTime);
      }
      for (int x = 0; x < _wheels.extraWheels.Length; x++) {
        if (_wheels.extraWheels[x].wheelCollider.suspensionDistance != height) {
          _wheels.extraWheels[x].wheelCollider.suspensionDistance = Mathf.MoveTowards(_wheels.extraWheels[x].wheelCollider.suspensionDistance, height, fixedDeltaTime);
        }
      }
    }

    public void SetWheelColliderFrictionOnStart(WheelCollider collider, bool useCustomFriction, float extSlipFW, float extValFW, float asySlipFW, float asyValueFW, float extSlipSL, float extValSL, float asySlipSL, float asyValueSL) {
      //friction Fw
      WheelFrictionCurve wheelFrictionCurveFW = new WheelFrictionCurve();
      if (useCustomFriction) {
        wheelFrictionCurveFW.extremumSlip = extSlipFW;
        wheelFrictionCurveFW.extremumValue = extValFW;
        wheelFrictionCurveFW.asymptoteSlip = asySlipFW;
        wheelFrictionCurveFW.asymptoteValue = asyValueFW;
        wheelFrictionCurveFW.stiffness = _groundFriction.standardForwardFriction;
      } else {
        wheelFrictionCurveFW.extremumSlip = _wheels.defaultFriction.ForwardFriction.ExtremumSlip;
        wheelFrictionCurveFW.extremumValue = _wheels.defaultFriction.ForwardFriction.ExtremumValue;
        wheelFrictionCurveFW.asymptoteSlip = _wheels.defaultFriction.ForwardFriction.AsymptoteSlip;
        wheelFrictionCurveFW.asymptoteValue = _wheels.defaultFriction.ForwardFriction.AsymptoteValue;
        wheelFrictionCurveFW.stiffness = _groundFriction.standardForwardFriction;
      }
      collider.forwardFriction = wheelFrictionCurveFW;

      //friction Sw
      WheelFrictionCurve wheelFrictionCurveSW = new WheelFrictionCurve();
      if (useCustomFriction) {
        wheelFrictionCurveSW.extremumSlip = extSlipSL;
        wheelFrictionCurveSW.extremumValue = extValSL;
        wheelFrictionCurveSW.asymptoteSlip = asySlipSL;
        wheelFrictionCurveSW.asymptoteValue = asyValueSL;
        wheelFrictionCurveSW.stiffness = _groundFriction.standardSideFriction;
      } else {
        wheelFrictionCurveSW.extremumSlip = _wheels.defaultFriction.SidewaysFriction.ExtremumSlip;
        wheelFrictionCurveSW.extremumValue = _wheels.defaultFriction.SidewaysFriction.ExtremumValue;
        wheelFrictionCurveSW.asymptoteSlip = _wheels.defaultFriction.SidewaysFriction.AsymptoteSlip;
        wheelFrictionCurveSW.asymptoteValue = _wheels.defaultFriction.SidewaysFriction.AsymptoteValue;
        wheelFrictionCurveSW.stiffness = _groundFriction.standardSideFriction;
      }
      collider.sidewaysFriction = wheelFrictionCurveSW;
    }



    void LightsManager() {
      float lightVerticalInput = 0.0f;

      if (_vehicleState == ControlState.isPlayer) {
        //MAIN LIGHTS
        for (int x = 0; x < _lights.mainLights.lights.Length; x++) {
          if (_lights.mainLights.lights[x]) {
            if (lowLightOn && !highLightOn) {
              _lights.mainLights.lights[x].enabled = true;
              _lights.mainLights.lights[x].intensity = _lights.mainLights.intensity * 0.5f;
              _lights.mainLights.lights[x].range = headlightsRange[x] * 0.5f;
            } else if (!lowLightOn && highLightOn) {
              _lights.mainLights.lights[x].enabled = true;
              _lights.mainLights.lights[x].intensity = _lights.mainLights.intensity;
              _lights.mainLights.lights[x].range = headlightsRange[x];
            } else if (!lowLightOn && !highLightOn) {
              _lights.mainLights.lights[x].enabled = false;
            }
          }
        }
        //
        if (lowLightOn && !highLightOn) {
          if (_lights.mainLights.meshesLightOn_low) {
            _lights.mainLights.meshesLightOn_low.SetActive(true);
          }
          if (_lights.mainLights.meshesLightOn_high) {
            _lights.mainLights.meshesLightOn_high.SetActive(false);
          }
          if (_lights.mainLights.meshesLightOff) {
            _lights.mainLights.meshesLightOff.SetActive(false);
          }
        } else if (!lowLightOn && highLightOn) {
          if (_lights.mainLights.meshesLightOn_low) {
            _lights.mainLights.meshesLightOn_low.SetActive(false);
          }
          if (_lights.mainLights.meshesLightOn_high) {
            _lights.mainLights.meshesLightOn_high.SetActive(true);
          }
          if (_lights.mainLights.meshesLightOff) {
            _lights.mainLights.meshesLightOff.SetActive(false);
          }
        } else if (!lowLightOn && !highLightOn) {
          if (_lights.mainLights.meshesLightOn_low) {
            _lights.mainLights.meshesLightOn_low.SetActive(false);
          }
          if (_lights.mainLights.meshesLightOn_high) {
            _lights.mainLights.meshesLightOn_high.SetActive(false);
          }
          if (_lights.mainLights.meshesLightOff) {
            _lights.mainLights.meshesLightOff.SetActive(true);
          }
        }

        //headlights
        for (int x = 0; x < _lights.headlights.lights.Length; x++) {
          if (_lights.headlights.lights[x]) {
            if (headlightsOn) {
              _lights.headlights.lights[x].enabled = true;
            } else {
              _lights.headlights.lights[x].enabled = false;
            }
          }
        }
        if (_lights.headlights.meshesLightOn) {
          _lights.headlights.meshesLightOn.SetActive(headlightsOn);
        }
        if (_lights.headlights.meshesLightOff) {
          _lights.headlights.meshesLightOff.SetActive(!headlightsOn);
        }

        //get input signal (on inside the car)
        lightVerticalInput = verticalInput;
        if (!isBraking) {
          lightVerticalInput = 0;
        }
        if (brakingAuto) {
          lightVerticalInput = -1.0f;
        }
      }

      //
      // 
      // SET MATERIAL IN LIGHTS
      // 
      //
      //reverseGearLights ==========================================================================
      bool insideInVehicle = false;
      if (_vehicleState == ControlState.isPlayer) {
        insideInVehicle = true;
      }
      for (int x = 0; x < _lights.reverseGearLights.lights.Length; x++) {
        if (_lights.reverseGearLights.lights[x]) {
          if (currentGear == -1 && insideInVehicle) {
            _lights.reverseGearLights.lights[x].enabled = true;
          } else {
            _lights.reverseGearLights.lights[x].enabled = false;
          }
        }
      }
      if (_lights.reverseGearLights.meshesLightOff) {
        if (currentGear == -1 && insideInVehicle) {//light on
          _lights.reverseGearLights.meshesLightOff.SetActive(false);
        } else {//light off
          _lights.reverseGearLights.meshesLightOff.SetActive(true);
        }
      }
      if (_lights.reverseGearLights.meshesLightOn) {
        if (currentGear == -1 && insideInVehicle) {//light on
          _lights.reverseGearLights.meshesLightOn.SetActive(true);
        } else {//light off
          _lights.reverseGearLights.meshesLightOn.SetActive(false);
        }
      }
      //


      //brakeLights ================================================================================================
      if (!automaticGears) {
        brakeLightIntensityParameter = brakeLightsIntensity + Mathf.Abs(Mathf.Clamp(lightVerticalInput, -1.0f, 0.0f));
      } else {
        if (currentGear > 0) {
          brakeLightIntensityParameter = brakeLightsIntensity + Mathf.Abs(Mathf.Clamp(lightVerticalInput, -1.0f, 0.0f));
        } else if (currentGear <= 0) {
          brakeLightIntensityParameter = brakeLightsIntensity + Mathf.Abs(Mathf.Clamp(lightVerticalInput, 0.0f, 1.0f));
        }
      }
      for (int x = 0; x < _lights.brakeLights.lights.Length; x++) {
        if (_lights.brakeLights.lights[x]) {
          _lights.brakeLights.lights[x].intensity = brakeLightIntensityParameter;
        }
      }
      if (_lights.brakeLights.meshesLightOff) {
        if (brakeLightIntensityParameter > 0.0f) {
          _lights.brakeLights.meshesLightOff.SetActive(false);
        } else {
          _lights.brakeLights.meshesLightOff.SetActive(true);
        }
      }
      if (_lights.brakeLights.meshesLightOn) {
        if (brakeLightIntensityParameter > 0.0f) {
          _lights.brakeLights.meshesLightOn.SetActive(true);
        } else {
          _lights.brakeLights.meshesLightOn.SetActive(false);
        }
      }
      //

      //rightFlashingLight ==============================================================================================
      intensityFlashingL = Mathf.PingPong(Time.time * _lights.flashingLights.speed, _lights.flashingLights.intensity);
      for (int x = 0; x < _lights.flashingLights.rightFlashingLight.light.Length; x++) {
        if (_lights.flashingLights.rightFlashingLight.light[x]) {
          if (rightBlinkersOn) {
            _lights.flashingLights.rightFlashingLight.light[x].enabled = true;
            _lights.flashingLights.rightFlashingLight.light[x].intensity = intensityFlashingL;
          } else {
            _lights.flashingLights.rightFlashingLight.light[x].enabled = false;
          }
        }
      }
      if (_lights.flashingLights.rightFlashingLight.meshesLightOff) {
        if (rightBlinkersOn && intensityFlashingL >= 0.4f) {
          _lights.flashingLights.rightFlashingLight.meshesLightOff.SetActive(false);
        } else {
          _lights.flashingLights.rightFlashingLight.meshesLightOff.SetActive(true);
        }
      }
      if (_lights.flashingLights.rightFlashingLight.meshesLightOn) {
        if (rightBlinkersOn && intensityFlashingL >= 0.4f) {
          _lights.flashingLights.rightFlashingLight.meshesLightOn.SetActive(true);
        } else {
          _lights.flashingLights.rightFlashingLight.meshesLightOn.SetActive(false);
        }
      }
      //leftFlashingLight ==============================================================================================
      for (int x = 0; x < _lights.flashingLights.leftFlashingLight.light.Length; x++) {
        if (_lights.flashingLights.leftFlashingLight.light[x]) {
          if (leftBlinkersOn) {
            _lights.flashingLights.leftFlashingLight.light[x].enabled = true;
            _lights.flashingLights.leftFlashingLight.light[x].intensity = intensityFlashingL;
          } else {
            _lights.flashingLights.leftFlashingLight.light[x].enabled = false;
          }
        }
      }
      if (_lights.flashingLights.leftFlashingLight.meshesLightOff) {
        if (leftBlinkersOn && intensityFlashingL >= 0.4f) {
          _lights.flashingLights.leftFlashingLight.meshesLightOff.SetActive(false);
        } else {
          _lights.flashingLights.leftFlashingLight.meshesLightOff.SetActive(true);
        }
      }
      if (_lights.flashingLights.leftFlashingLight.meshesLightOn) {
        if (leftBlinkersOn && intensityFlashingL >= 0.4f) {
          _lights.flashingLights.leftFlashingLight.meshesLightOn.SetActive(true);
        } else {
          _lights.flashingLights.leftFlashingLight.meshesLightOn.SetActive(false);
        }
      }
      //


      //extraLights =============================================================================================
      intensitySirenL = Mathf.PingPong(Time.time * _lights.extraLights.speed, _lights.extraLights.intensity);
      if (_lights.extraLights.lightEffect == ExtraLightsClass.TipoLuz.Continnous) {
        intensitySirenL = 1;
      }
      for (int x = 0; x < _lights.extraLights.lights.Length; x++) {
        if (_lights.extraLights.lights[x]) {
          if (extraLightsOn) {
            _lights.extraLights.lights[x].enabled = true;
            _lights.extraLights.lights[x].intensity = intensitySirenL;
          } else {
            _lights.extraLights.lights[x].enabled = false;
          }
        }
      }
      if (_lights.extraLights.meshesLightOff) {
        if (extraLightsOn) {
          _lights.extraLights.meshesLightOff.SetActive(false);
        } else {
          _lights.extraLights.meshesLightOff.SetActive(true);
        }
      }
      if (_lights.extraLights.meshesLightOn) {
        if (extraLightsOn) {
          _lights.extraLights.meshesLightOn.SetActive(true);
        } else {
          _lights.extraLights.meshesLightOn.SetActive(false);
        }
      }
    }



    void DisableAllLightsOnStart() {
      disableBlinkers2 = disableBlinkers1 = alertOn = headlightsOn = highLightOn = lowLightOn = rightBlinkersOn = leftBlinkersOn = extraLightsOn = false;
      //brake lights===================================================================================
      for (int x = 0; x < _lights.brakeLights.lights.Length; x++) {//brake
        if (_lights.brakeLights.lights[x]) {
          _lights.brakeLights.lights[x].enabled = false;
        }
      }
      if (_lights.brakeLights.meshesLightOn) {
        _lights.brakeLights.meshesLightOn.SetActive(false);
      }
      if (_lights.brakeLights.meshesLightOff) {
        _lights.brakeLights.meshesLightOff.SetActive(true);
      }
      //
      //reverse lights===================================================================================
      for (int x = 0; x < _lights.reverseGearLights.lights.Length; x++) {//reverse
        if (_lights.reverseGearLights.lights[x]) {
          _lights.reverseGearLights.lights[x].enabled = false;
        }
      }
      if (_lights.reverseGearLights.meshesLightOn) {
        _lights.reverseGearLights.meshesLightOn.SetActive(false);
      }
      if (_lights.reverseGearLights.meshesLightOff) {
        _lights.reverseGearLights.meshesLightOff.SetActive(true);
      }
      //
      //main lights===================================================================================
      for (int x = 0; x < _lights.mainLights.lights.Length; x++) {//main
        if (_lights.mainLights.lights[x]) {
          _lights.mainLights.lights[x].enabled = false;
        }
      }
      if (_lights.mainLights.meshesLightOn_low) {
        _lights.mainLights.meshesLightOn_low.SetActive(false);
      }
      if (_lights.mainLights.meshesLightOn_high) {
        _lights.mainLights.meshesLightOn_high.SetActive(false);
      }
      if (_lights.mainLights.meshesLightOff) {
        _lights.mainLights.meshesLightOff.SetActive(true);
      }
      //
      //extra lights===================================================================================
      for (int x = 0; x < _lights.extraLights.lights.Length; x++) {
        if (_lights.extraLights.lights[x]) {
          _lights.extraLights.lights[x].enabled = false;
        }
      }
      if (_lights.extraLights.meshesLightOn) {
        _lights.extraLights.meshesLightOn.SetActive(false);
      }
      if (_lights.extraLights.meshesLightOff) {
        _lights.extraLights.meshesLightOff.SetActive(true);
      }
      //
      //head lights===================================================================================
      for (int x = 0; x < _lights.headlights.lights.Length; x++) {
        if (_lights.headlights.lights[x]) {
          _lights.headlights.lights[x].enabled = false;
        }
      }
      if (_lights.headlights.meshesLightOn) {
        _lights.headlights.meshesLightOn.SetActive(false);
      }
      if (_lights.headlights.meshesLightOff) {
        _lights.headlights.meshesLightOff.SetActive(true);
      }
      //
      //rightFlashingLight===================================================================================
      for (int x = 0; x < _lights.flashingLights.rightFlashingLight.light.Length; x++) {
        if (_lights.flashingLights.rightFlashingLight.light[x]) {
          _lights.flashingLights.rightFlashingLight.light[x].enabled = false;
        }
      }
      if (_lights.flashingLights.rightFlashingLight.meshesLightOn) {
        _lights.flashingLights.rightFlashingLight.meshesLightOn.SetActive(false);
      }
      if (_lights.flashingLights.rightFlashingLight.meshesLightOff) {
        _lights.flashingLights.rightFlashingLight.meshesLightOff.SetActive(true);
      }
      //
      //leftFlashingLight===================================================================================
      for (int x = 0; x < _lights.flashingLights.leftFlashingLight.light.Length; x++) {
        if (_lights.flashingLights.leftFlashingLight.light[x]) {
          _lights.flashingLights.leftFlashingLight.light[x].enabled = false;
        }
      }
      if (_lights.flashingLights.leftFlashingLight.meshesLightOn) {
        _lights.flashingLights.leftFlashingLight.meshesLightOn.SetActive(false);
      }
      if (_lights.flashingLights.leftFlashingLight.meshesLightOff) {
        _lights.flashingLights.leftFlashingLight.meshesLightOff.SetActive(true);
      }
    }

    void SetLightsValues(Light light, LightType type, bool startLightOn, Color lightColor, float intensity, bool shadows, LightRenderMode RendType) {
      light.type = type;
      light.enabled = startLightOn;
      light.renderMode = RendType;
      light.color = lightColor;
      light.intensity = intensity;
      light.shadowStrength = 0.0f;
      if (shadows) {
        light.shadows = LightShadows.Soft;
        light.shadowStrength = 1;
      } else {
        light.shadows = LightShadows.None;
      }
      if (light.transform.gameObject.activeSelf == false) {
        light.transform.gameObject.SetActive(true);
      }
    }

    void SetLightValuesStart() {
      //enable or disable UI buttons (all these variables are 'false' by default)
      //mainLights
      if ((_lights.mainLights.lights.Length > 0) || (_lights.mainLights.meshesLightOff && _lights.mainLights.meshesLightOn_low && _lights.mainLights.meshesLightOn_high)) {
        msvs_useMainLights = true;
      }
      //headLights
      if ((_lights.headlights.lights.Length > 0) || (_lights.headlights.meshesLightOff && _lights.headlights.meshesLightOn)) {
        msvs_useHeadLights = true;
      }
      //extraLights
      if ((_lights.extraLights.lights.Length > 0) && (_lights.extraLights.meshesLightOn && _lights.extraLights.meshesLightOff)) {
        msvs_useExtraLights = true;
      }
      //flashing or warning lights
      if ((_lights.flashingLights.leftFlashingLight.light.Length > 0 && _lights.flashingLights.rightFlashingLight.light.Length > 0)) {
        msvs_useWarningOrFlashingLights = true;
      }
      if (_lights.flashingLights.leftFlashingLight.meshesLightOff && _lights.flashingLights.leftFlashingLight.meshesLightOn && _lights.flashingLights.rightFlashingLight.meshesLightOff && _lights.flashingLights.rightFlashingLight.meshesLightOn) {
        msvs_useWarningOrFlashingLights = true;
      }

      //
      //get light ranger to low light and high light (luz baixa e luz alta)
      headlightsRange = new float[_lights.mainLights.lights.Length];
      for (int x = 0; x < _lights.mainLights.lights.Length; x++) {
        if (_lights.mainLights.lights[x]) {
          headlightsRange[x] = _lights.mainLights.lights[x].range;
        } else {
          headlightsRange[x] = 40;
        }
      }
      brakeLightsIntensity = 0;
      disableBlinkers2 = disableBlinkers1 = alertOn = headlightsOn = highLightOn = lowLightOn = rightBlinkersOn = leftBlinkersOn = extraLightsOn = false;
      for (int x = 0; x < _lights.brakeLights.lights.Length; x++) {//brake
        if (_lights.brakeLights.lights[x]) {
          SetLightsValues(_lights.brakeLights.lights[x], LightType.Point, true, _lights.brakeLights.color, _lights.brakeLights.intensity, _lights.brakeLights.shadow, _lights.brakeLights.renderMode);
        }
      }
      for (int x = 0; x < _lights.reverseGearLights.lights.Length; x++) {//reverse
        if (_lights.reverseGearLights.lights[x]) {
          SetLightsValues(_lights.reverseGearLights.lights[x], LightType.Point, false, _lights.reverseGearLights.color, _lights.reverseGearLights.intensity, _lights.reverseGearLights.shadow, _lights.reverseGearLights.renderMode);
        }
      }
      for (int x = 0; x < _lights.mainLights.lights.Length; x++) {//main
        if (_lights.mainLights.lights[x]) {
          SetLightsValues(_lights.mainLights.lights[x], LightType.Spot, false, _lights.mainLights.color, _lights.mainLights.intensity, _lights.mainLights.shadow, _lights.mainLights.renderMode);
          _lights.mainLights.lights[x].transform.rotation = transform.rotation;
        }
      }
      for (int x = 0; x < _lights.flashingLights.rightFlashingLight.light.Length; x++) {//right
        if (_lights.flashingLights.rightFlashingLight.light[x]) {
          SetLightsValues(_lights.flashingLights.rightFlashingLight.light[x], LightType.Point, false, _lights.flashingLights.color, _lights.flashingLights.intensity, _lights.flashingLights.shadow, _lights.flashingLights.renderMode);
        }
      }
      for (int x = 0; x < _lights.flashingLights.rightFlashingLight.light.Length; x++) {//left
        if (_lights.flashingLights.leftFlashingLight.light[x]) {
          SetLightsValues(_lights.flashingLights.leftFlashingLight.light[x], LightType.Point, false, _lights.flashingLights.color, _lights.flashingLights.intensity, _lights.flashingLights.shadow, _lights.flashingLights.renderMode);
        }
      }
      for (int x = 0; x < _lights.extraLights.lights.Length; x++) {
        if (_lights.extraLights.lights[x]) {
          SetLightsValues(_lights.extraLights.lights[x], _lights.extraLights.lightType, false, _lights.extraLights.color, _lights.extraLights.intensity, _lights.extraLights.shadow, _lights.extraLights.renderMode);
        }
      }
      for (int x = 0; x < _lights.headlights.lights.Length; x++) {
        if (_lights.headlights.lights[x]) {
          SetLightsValues(_lights.headlights.lights[x], LightType.Spot, false, _lights.headlights.color, _lights.headlights.intensity, _lights.headlights.shadow, _lights.headlights.renderMode);
          _lights.headlights.lights[x].transform.rotation = transform.rotation;
        }
      }
    }



    int GetDominantTerrainTextureInWorldPosition(Vector3 worldPosition) {
      terrainCompositionArray = TerrainComposition(worldPosition, activeTerrain_optional);
      if (terrainCompositionArray != null) {
        int dominantIndex = 0;
        float maximumCompositionMix = 0;
        for (int x = 0; x < terrainCompositionArray.Length; ++x) {
          if (terrainCompositionArray[x] > maximumCompositionMix) {
            dominantIndex = x;
            maximumCompositionMix = terrainCompositionArray[x];
          }
        }
        return dominantIndex;
      } else {
        return -1;
      }
    }
    float[] TerrainComposition(Vector3 worldPosition, Terrain myTerrain) {
      try {
        if (!myTerrain) {
          myTerrain = Terrain.activeTerrain;
        }
        terrainData = myTerrain.terrainData;
        int terrainPosX = (int)(((worldPosition.x - myTerrain.transform.position.x) / terrainData.size.x) * terrainData.alphamapWidth);
        int terrainPosZ = (int)(((worldPosition.z - myTerrain.transform.position.z) / terrainData.size.z) * terrainData.alphamapHeight);
        if (terrainPosX >= terrainData.alphamapWidth || terrainPosZ >= terrainData.alphamapHeight) { // if world position > terrain size
          return null;
        }
        //
        alphaMaps = terrainData.GetAlphamaps(terrainPosX, terrainPosZ, 1, 1);
        terrainCompositionMix = new float[alphaMaps.GetUpperBound(2) + 1];
        for (int x = 0; x < terrainCompositionMix.Length; ++x) {
          terrainCompositionMix[x] = alphaMaps[0, 0, x];
        }
        return terrainCompositionMix;
      } catch {
        return null;
      }
    }



    void CheckGroundForSKidMarks() {
      if (_wheels.rightFrontWheel.wheelCollider) {
        if (wheelFDIsGrounded) {
          _wheels.rightFrontWheel.generateSkidBool = GenerateSkidMarks(_wheels.rightFrontWheel.wheelCollider, _wheels.rightFrontWheel.wheelWorldPosition,
            _wheels.rightFrontWheel.rendSKDmarks, _wheels.rightFrontWheel.generateSkidBool, _wheels.rightFrontWheel.skidMarkShift, 0
            , _wheels.rightFrontWheel.useCustomBrandWidth, _wheels.rightFrontWheel.customBrandWidth);
        } else {
          _wheels.rightFrontWheel.generateSkidBool = false;
        }
      }
      //
      if (_wheels.leftFrontWheel.wheelCollider) {
        if (wheelFEIsGrounded) {
          _wheels.leftFrontWheel.generateSkidBool = GenerateSkidMarks(_wheels.leftFrontWheel.wheelCollider, _wheels.leftFrontWheel.wheelWorldPosition,
            _wheels.leftFrontWheel.rendSKDmarks, _wheels.leftFrontWheel.generateSkidBool, _wheels.leftFrontWheel.skidMarkShift, 1
            , _wheels.leftFrontWheel.useCustomBrandWidth, _wheels.leftFrontWheel.customBrandWidth);
        } else {
          _wheels.leftFrontWheel.generateSkidBool = false;
        }
      }
      //
      if (_wheels.rightRearWheel.wheelCollider) {
        if (wheelTDIsGrounded) {
          _wheels.rightRearWheel.generateSkidBool = GenerateSkidMarks(_wheels.rightRearWheel.wheelCollider, _wheels.rightRearWheel.wheelWorldPosition,
            _wheels.rightRearWheel.rendSKDmarks, _wheels.rightRearWheel.generateSkidBool, _wheels.rightRearWheel.skidMarkShift, 2
            , _wheels.rightRearWheel.useCustomBrandWidth, _wheels.rightRearWheel.customBrandWidth);
        } else {
          _wheels.rightRearWheel.generateSkidBool = false;
        }
      }
      //
      if (_wheels.leftRearWheel.wheelCollider) {
        if (wheelTEIsGrounded) {
          _wheels.leftRearWheel.generateSkidBool = GenerateSkidMarks(_wheels.leftRearWheel.wheelCollider, _wheels.leftRearWheel.wheelWorldPosition,
            _wheels.leftRearWheel.rendSKDmarks, _wheels.leftRearWheel.generateSkidBool, _wheels.leftRearWheel.skidMarkShift, 3
            , _wheels.leftRearWheel.useCustomBrandWidth, _wheels.leftRearWheel.customBrandWidth);
        } else {
          _wheels.leftRearWheel.generateSkidBool = false;
        }
      }
      //
      for (int x = 0; x < _wheels.extraWheels.Length; x++) {
        if (_wheels.extraWheels[x].wheelCollider) {
          if (_wheels.extraWheels[x].wheelCollider.isGrounded) {
            _wheels.extraWheels[x].generateSkidBool = GenerateSkidMarks(_wheels.extraWheels[x].wheelCollider, _wheels.extraWheels[x].wheelWorldPosition,
              _wheels.extraWheels[x].rendSKDmarks, _wheels.extraWheels[x].generateSkidBool, _wheels.extraWheels[x].skidMarkShift, (x + 4)
              , _wheels.extraWheels[x].useCustomBrandWidth, _wheels.extraWheels[x].customBrandWidth);
          } else {
            _wheels.extraWheels[x].generateSkidBool = false;
          }
        }
      }
    }

    private int GetCurrentVerticeIndexForMesh(Mesh mesh) {
      int result;
      currentIndexes.TryGetValue(mesh, out result);
      result += 2;
      result %= mesh.vertexCount;
      result += mesh.vertexCount;
      currentIndexes[mesh] = result;
      return result;
    }

    private static T GetRepeatedArrayValue<T>(List<T> array, int index) {
      return array[GetRepeatedArrayIndex(array, index)];
    }

    private static int GetRepeatedArrayIndex<T>(List<T> array, int index) {
      return (index + array.Count) % array.Count;
    }

    private bool GenerateSkidMarks(WheelCollider wheelCollider, Vector3 wheelPos, Mesh wheelSkidMesh, bool generateBool, float lateralDisplacement, int indexLastMark, bool customWidthBool, float customWidthFloat) {
      if (!wheelCollider.GetGroundHit(out tempWheelHit) || !wheelCollider.isGrounded) {
        return false;
      }
      tempWheelHit.point = wheelPos - wheelCollider.transform.up * wheelCollider.radius * vehicleScale;
      float tempAlphaSkidMarks = Mathf.Abs(tempWheelHit.sidewaysSlip);
      if (Mathf.Abs(tempWheelHit.forwardSlip * _skidMarks.forwordSensibility) > tempAlphaSkidMarks) {
        tempAlphaSkidMarks = Mathf.Abs(tempWheelHit.forwardSlip * _skidMarks.forwordSensibility);
      }
      //
      float widthSkidMarks = _skidMarks.standardBrandWidth;
      if (customWidthBool) {
        widthSkidMarks = customWidthFloat;
      }
      //
      Vector3 skidTemp = tempWheelHit.sidewaysDir * (widthSkidMarks * vehicleScale) / 2f * Vector3.Dot(wheelCollider.attachedRigidbody.velocity.normalized, tempWheelHit.forwardDir);
      skidTemp -= tempWheelHit.forwardDir * (widthSkidMarks * vehicleScale) * 0.1f * Vector3.Dot(wheelCollider.attachedRigidbody.velocity.normalized, tempWheelHit.sidewaysDir);
      if (KMh > (75.0f / _skidMarks.sensibility) && Mathf.Abs(wheelCollider.rpm) < (3.0f / _skidMarks.sensibility)) {
        if (wheelCollider.isGrounded) {
          tempAlphaSkidMarks = 10;
        }
      }
      if (KMh < 20.0f * (Mathf.Clamp(_skidMarks.sensibility, 1, 3))) {
        if (Mathf.Abs(tempWheelHit.forwardSlip * _skidMarks.forwordSensibility) > (1.2f / _skidMarks.sensibility)) {
          if (wheelCollider.isGrounded) {
            tempAlphaSkidMarks = 10;
          }
        }
      }
      float RPMCondition = (1.75f / averageWheelRadius);// = 5.0f
      if (Mathf.Abs(wheelCollider.rpm) < RPMCondition && KMh > 5) {
        if (wheelCollider.isGrounded) {
          tempAlphaSkidMarks = 10;
        }
      }

      bool breakForAlphaSkidMarks = false;
      for (int x = 0; x < _skidMarks.otherGround.Length; x++) {
        if (!breakForAlphaSkidMarks) {
          switch (_groundDetection) {
            case GroundDetectionMode.Tag:
              if (!string.IsNullOrEmpty(_skidMarks.otherGround[x].groundTag)) {
                if (tempWheelHit.collider.gameObject.CompareTag(_skidMarks.otherGround[x].groundTag)) {
                  if (_skidMarks.otherGround[x].continuousMarking) {
                    tempAlphaSkidMarks = 10;
                  }
                  breakForAlphaSkidMarks = true;
                }
              }
              break;
            //==============================================================================================================================
            case GroundDetectionMode.PhysicMaterial:
              if (_skidMarks.otherGround[x].physicMaterial) {
                if (tempWheelHit.collider.sharedMaterial == _skidMarks.otherGround[x].physicMaterial) {
                  if (_skidMarks.otherGround[x].continuousMarking) {
                    tempAlphaSkidMarks = 10;
                  }
                  breakForAlphaSkidMarks = true;
                }
              }
              break;
            //==============================================================================================================================
            case GroundDetectionMode.TerrainTextureIndices:
              if (activeTerrain_optional) {
                if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                  int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                  if (dominantTerrainIndex != -1) {
                    if (_skidMarks.otherGround[x].terrainTextureIndices.Count > 0 && _skidMarks.otherGround[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                      if (_skidMarks.otherGround[x].continuousMarking) {
                        tempAlphaSkidMarks = 10;
                      }
                      breakForAlphaSkidMarks = true;
                    }
                  }
                }
              }
              break;
            //==============================================================================================================================
            case GroundDetectionMode.All:
              //tag
              if (!string.IsNullOrEmpty(_skidMarks.otherGround[x].groundTag)) {
                if (tempWheelHit.collider.gameObject.CompareTag(_skidMarks.otherGround[x].groundTag)) {
                  if (_skidMarks.otherGround[x].continuousMarking) {
                    tempAlphaSkidMarks = 10;
                  }
                  breakForAlphaSkidMarks = true;
                  break;
                }
              }
              //physicMaterial
              if (_skidMarks.otherGround[x].physicMaterial) {
                if (tempWheelHit.collider.sharedMaterial == _skidMarks.otherGround[x].physicMaterial) {
                  if (_skidMarks.otherGround[x].continuousMarking) {
                    tempAlphaSkidMarks = 10;
                  }
                  breakForAlphaSkidMarks = true;
                  break;
                }
              }
              //terrainTextureIndice
              if (activeTerrain_optional) {
                if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                  int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                  if (dominantTerrainIndex != -1) {
                    if (_skidMarks.otherGround[x].terrainTextureIndices.Count > 0 && _skidMarks.otherGround[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                      if (_skidMarks.otherGround[x].continuousMarking) {
                        tempAlphaSkidMarks = 10;
                      }
                      breakForAlphaSkidMarks = true;
                    }
                  }
                }
              }
              break;
              //==============================================================================================================================
          }
        }
      }

      if (tempAlphaSkidMarks < (1 / _skidMarks.sensibility)) {
        return false;
      }
      float distance = (lastPoint[indexLastMark] - tempWheelHit.point - skidTemp).sqrMagnitude;
      float alphaAplic = Mathf.Clamp(tempAlphaSkidMarks, 0.0f, 1.0f);

      if (generateBool) {
        if (distance < 0.1f) {
          return true;
        }
      }

      wheelSkidMesh.GetVertices(vertices);
      wheelSkidMesh.GetNormals(normals);
      wheelSkidMesh.GetTriangles(tris, 0);
      wheelSkidMesh.GetColors(colors);
      wheelSkidMesh.GetUVs(0, uv);

      int verLenght = GetCurrentVerticeIndexForMesh(wheelSkidMesh);
      int triLength = verLenght * 3;

      vertices[GetRepeatedArrayIndex(vertices, verLenght - 1)] = tempWheelHit.point + tempWheelHit.normal * _skidMarks.groundDistance - skidTemp + tempWheelHit.sidewaysDir * lateralDisplacement;
      vertices[GetRepeatedArrayIndex(vertices, verLenght - 2)] = tempWheelHit.point + tempWheelHit.normal * _skidMarks.groundDistance + skidTemp + tempWheelHit.sidewaysDir * lateralDisplacement;
      normals[GetRepeatedArrayIndex(normals, verLenght - 1)] = normals[GetRepeatedArrayIndex(normals, verLenght - 2)] = tempWheelHit.normal;

      Color skidMarkColor = _skidMarks.standardColor;
      skidMarkColor.a = Mathf.Clamp(alphaAplic * _skidMarks.standardOpacity, 0.01f, 1.0f);

      bool changeColor = false;
      for (int x = 0; x < _skidMarks.otherGround.Length; x++) {
        if (!changeColor) {
          switch (_groundDetection) {
            case GroundDetectionMode.Tag:
              if (!string.IsNullOrEmpty(_skidMarks.otherGround[x].groundTag)) {
                if (tempWheelHit.collider.gameObject.CompareTag(_skidMarks.otherGround[x].groundTag)) {
                  skidMarkColor = _skidMarks.otherGround[x].color;
                  skidMarkColor.a = Mathf.Clamp(alphaAplic * _skidMarks.otherGround[x].opacity, 0.01f, 1.0f);
                  changeColor = true;
                  break;
                }
              }
              break;
            //==============================================================================================================================
            case GroundDetectionMode.PhysicMaterial:
              if (_skidMarks.otherGround[x].physicMaterial) {
                if (tempWheelHit.collider.sharedMaterial == _skidMarks.otherGround[x].physicMaterial) {
                  skidMarkColor = _skidMarks.otherGround[x].color;
                  skidMarkColor.a = Mathf.Clamp(alphaAplic * _skidMarks.otherGround[x].opacity, 0.01f, 1.0f);
                  changeColor = true;
                  break;
                }
              }
              break;
            //==============================================================================================================================
            case GroundDetectionMode.TerrainTextureIndices:
              if (activeTerrain_optional) {
                if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                  int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                  if (dominantTerrainIndex != -1) {
                    if (_skidMarks.otherGround[x].terrainTextureIndices.Count > 0 && _skidMarks.otherGround[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                      skidMarkColor = _skidMarks.otherGround[x].color;
                      skidMarkColor.a = Mathf.Clamp(alphaAplic * _skidMarks.otherGround[x].opacity, 0.01f, 1.0f);
                      changeColor = true;
                      break;
                    }
                  }
                }
              }
              break;
            //==============================================================================================================================
            case GroundDetectionMode.All:
              //tag
              if (!string.IsNullOrEmpty(_skidMarks.otherGround[x].groundTag)) {
                if (tempWheelHit.collider.gameObject.CompareTag(_skidMarks.otherGround[x].groundTag)) {
                  skidMarkColor = _skidMarks.otherGround[x].color;
                  skidMarkColor.a = Mathf.Clamp(alphaAplic * _skidMarks.otherGround[x].opacity, 0.01f, 1.0f);
                  changeColor = true;
                  break;
                }
              }
              //physicMaterial
              if (_skidMarks.otherGround[x].physicMaterial) {
                if (tempWheelHit.collider.sharedMaterial == _skidMarks.otherGround[x].physicMaterial) {
                  skidMarkColor = _skidMarks.otherGround[x].color;
                  skidMarkColor.a = Mathf.Clamp(alphaAplic * _skidMarks.otherGround[x].opacity, 0.01f, 1.0f);
                  changeColor = true;
                  break;
                }
              }
              //terrainTextureIndice
              if (activeTerrain_optional) {
                if (tempWheelHit.collider.gameObject == activeTerrain_optional.gameObject) {
                  int dominantTerrainIndex = GetDominantTerrainTextureInWorldPosition(tempWheelHit.point);
                  if (dominantTerrainIndex != -1) {
                    if (_skidMarks.otherGround[x].terrainTextureIndices.Count > 0 && _skidMarks.otherGround[x].terrainTextureIndices.Contains(dominantTerrainIndex)) {
                      skidMarkColor = _skidMarks.otherGround[x].color;
                      skidMarkColor.a = Mathf.Clamp(alphaAplic * _skidMarks.otherGround[x].opacity, 0.01f, 1.0f);
                      changeColor = true;
                      break;
                    }
                  }
                }
              }
              break;
              //==============================================================================================================================
          }
        }
      }

      colors[GetRepeatedArrayIndex(colors, verLenght - 1)] = colors[GetRepeatedArrayIndex(colors, verLenght - 2)] = skidMarkColor;

      tris[GetRepeatedArrayIndex(tris, triLength + 0)] = tris[GetRepeatedArrayIndex(tris, triLength + 3)] =
        tris[GetRepeatedArrayIndex(tris, triLength + 1)] = tris[GetRepeatedArrayIndex(tris, triLength + 4)] =
          tris[GetRepeatedArrayIndex(tris, triLength + 2)] = tris[GetRepeatedArrayIndex(tris, triLength + 5)] =
            tris[GetRepeatedArrayIndex(tris, triLength + 6)] = tris[GetRepeatedArrayIndex(tris, triLength + 9)] =
              tris[GetRepeatedArrayIndex(tris, triLength + 7)] = tris[GetRepeatedArrayIndex(tris, triLength + 10)] =
                tris[GetRepeatedArrayIndex(tris, triLength + 8)] = tris[GetRepeatedArrayIndex(tris, triLength + 11)];

      if (generateBool) {
        tris[GetRepeatedArrayIndex(tris, triLength - 1)] = GetRepeatedArrayIndex(vertices, verLenght - 2);
        tris[GetRepeatedArrayIndex(tris, triLength - 2)] = GetRepeatedArrayIndex(vertices, verLenght - 1);
        tris[GetRepeatedArrayIndex(tris, triLength - 3)] = GetRepeatedArrayIndex(vertices, verLenght - 3);
        tris[GetRepeatedArrayIndex(tris, triLength - 4)] = GetRepeatedArrayIndex(vertices, verLenght - 3);
        tris[GetRepeatedArrayIndex(tris, triLength - 5)] = GetRepeatedArrayIndex(vertices, verLenght - 4);
        tris[GetRepeatedArrayIndex(tris, triLength - 6)] = GetRepeatedArrayIndex(vertices, verLenght - 2);

        uv[GetRepeatedArrayIndex(uv, verLenght - 1)] =
          uv[GetRepeatedArrayIndex(uv, verLenght - 3)] + Vector2.right * distance * 0.01f;
        uv[GetRepeatedArrayIndex(uv, verLenght - 2)] =
          uv[GetRepeatedArrayIndex(uv, verLenght - 4)] + Vector2.right * distance * 0.01f;

      } else {
        uv[GetRepeatedArrayIndex(uv, verLenght - 1)] = Vector2.zero;
        uv[GetRepeatedArrayIndex(uv, verLenght - 2)] = Vector2.up;
      }
      lastPoint[indexLastMark] = vertices[GetRepeatedArrayIndex(vertices, verLenght - 1)];
      wheelSkidMesh.SetVertices(vertices);
      wheelSkidMesh.SetNormals(normals);
      wheelSkidMesh.SetTriangles(tris, 0);
      wheelSkidMesh.SetColors(colors);
      wheelSkidMesh.SetUVs(0, uv);
      wheelSkidMesh.RecalculateBounds();
      return true;
    }

    Mesh GerarRendRef(Material skdMaterial, string wheelName) {
      GameObject rendRef = new("SkidMesh " + wheelName + " " + transform.name);
      rendRef.AddComponent<MeshFilter>();
      rendRef.AddComponent<MeshRenderer>();
      Mesh mesh = rendRef.GetComponent<MeshFilter>().mesh = new Mesh();
      mesh.vertices = new Vector3[CacheSize];
      mesh.normals = new Vector3[CacheSize];
      mesh.uv = new Vector2[CacheSize];
      mesh.colors = new Color[CacheSize];
      mesh.triangles = new int[CacheSize * 3];
      mesh.MarkDynamic();
      rendRef.GetComponent<MeshRenderer>().material = skdMaterial;
      rendRef.GetComponent<MeshRenderer>().shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
      rendRef.transform.parent = SkidMarksContainer;
      return mesh;
    }

    void SetSkidMarksValues() {
      Material skidmarkMaterial;
      if (_skidMarks.customMaterial) {
        skidmarkMaterial = _skidMarks.customMaterial;
      } else {
        skidmarkMaterial = new Material(skidMarksShader);
        skidmarkMaterial.mainTexture = GenerateTextureAndNormalMap(true);
        skidmarkMaterial.SetTexture("_NormalMap", GenerateTextureAndNormalMap(false));
        skidmarkMaterial.SetFloat("_NormFactor", _skidMarks.normalMapIntensity);
        skidmarkMaterial.SetFloat("_Glossiness", _skidMarks.smoothness);
        skidmarkMaterial.SetFloat("_Metallic", _skidMarks.metallic);
      }
      Color skidColor = _skidMarks.standardColor;
      skidColor.a = _skidMarks.standardOpacity;
      skidmarkMaterial.color = skidColor;
      //
      _wheels.rightFrontWheel.rendSKDmarks = GerarRendRef(skidmarkMaterial, _wheels.rightFrontWheel.wheelCollider.gameObject.transform.name);
      _wheels.leftFrontWheel.rendSKDmarks = GerarRendRef(skidmarkMaterial, _wheels.leftFrontWheel.wheelCollider.gameObject.transform.name);
      _wheels.rightRearWheel.rendSKDmarks = GerarRendRef(skidmarkMaterial, _wheels.rightRearWheel.wheelCollider.gameObject.transform.name);
      _wheels.leftRearWheel.rendSKDmarks = GerarRendRef(skidmarkMaterial, _wheels.leftRearWheel.wheelCollider.gameObject.transform.name);
      for (int x = 0; x < _wheels.extraWheels.Length; x++) {
        _wheels.extraWheels[x].rendSKDmarks = GerarRendRef(skidmarkMaterial, _wheels.extraWheels[x].wheelCollider.gameObject.transform.name);
      }
    }

    public Texture GenerateTextureAndNormalMap(bool isTexture) {
      Texture2D texture = new Texture2D(32, 32, TextureFormat.ARGB32, false);
      Color transparentColor1 = new Color(0.0f, 0.0f, 0.0f, 0.5f);
      Color transparentColor2 = new Color(0.0f, 0.0f, 0.0f, 1.0f);
      if (isTexture) {
        transparentColor1 = new Color(1.0f, 1.0f, 1.0f, 0.15f);
        transparentColor2 = new Color(1.0f, 1.0f, 1.0f, 0.6f);
      }
      for (int x = 0; x < 32; x++) {
        for (int y = 0; y < 32; y++) {
          texture.SetPixel(x, y, Color.white);
        }
      }
      for (int y = 0; y < 32; y++) {
        for (int x = 0; x < 32; x++) {
          if (y == 0 || y == 1 || y == 30 || y == 31) {
            texture.SetPixel(x, y, transparentColor1);
          }
          if (y == 6 || y == 7 || y == 15 || y == 16 || y == 24 || y == 25) {
            texture.SetPixel(x, y, transparentColor2);
          }
        }
      }
      texture.Apply();
      return texture;
    }

  }
}
